0000: 80 67    JMP   0x0068
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0001) ; Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0002) ;
                                   (0003) ;@Id: boot.tpl#682 @
                                   (0004) ;=============================================================================
                                   (0005) ;  FILENAME:   boot.asm
                                   (0006) ;  VERSION:    4.16
                                   (0007) ;  DATE:       6 October 2005
                                   (0008) ;
                                   (0009) ;  DESCRIPTION:
                                   (0010) ;  M8C Boot Code for CY8C24x90 microcontroller devices.
                                   (0011) ;
                                   (0012) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
                                   (0013) ;
                                   (0014) ; NOTES:
                                   (0015) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                   (0016) ; the project's root directory to create BOOT.ASM. Any changes made to
                                   (0017) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0018) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0019) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                   (0020) ; are not accidentally modified.
                                   (0021) ;
                                   (0022) ;=============================================================================
                                   (0023) 
                                   (0024) include ".\lib\GlobalParams.inc"
                                   (0025) include "m8c.inc"
                                   (0026) include "m8ssc.inc"
                                   (0027) include "memory.inc"
                                   (0028) 
                                   (0029) ;--------------------------------------
                                   (0030) ; Export Declarations
                                   (0031) ;--------------------------------------
                                   (0032) 
                                   (0033) export __Start
                                   (0034) export __bss_start
                                   (0035) export __data_start
                                   (0036) export __idata_start
                                   (0037) export __func_lit_start
                                   (0038) export __text_start
                                   (0039) export  _bGetPowerSetting
                                   (0040) export   bGetPowerSetting
                                   (0041) 
                                   (0042) 
                                   (0043) ;--------------------------------------
                                   (0044) ; Optimization flags
                                   (0045) ;--------------------------------------
                                   (0046) ;
                                   (0047) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0048) ; boot.asm. See the notes in the banner comment at the beginning of
                                   (0049) ; this file.
                                   (0050) 
                                   (0051) ; Optimization for Assembly language (only) projects and C-language projects
                                   (0052) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                   (0053) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0054) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0055) ;
                                   (0056) C_LANGUAGE_SUPPORT:              equ 1
                                   (0057) 
                                   (0058) 
                                   (0059) ; For historical reasons, by default the boot code uses an lcall instruction
                                   (0060) ; to invoke the user's _main code. If _main executes a return instruction,
                                   (0061) ; boot provides an infinite loop. By changing the following equate from zero
                                   (0062) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0063) ; bytes on the stack which are otherwise required for the return address. If
                                   (0064) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                   (0065) ; release, the C compiler automatically places an infinite loop at the end
                                   (0066) ; of main, rather than a return instruction.)
                                   (0067) ;
                                   (0068) ENABLE_LJMP_TO_MAIN:             equ 0
                                   (0069) 
                                   (0070) 
                                   (0071) ;-----------------------------------------------------------------------------
                                   (0072) ; Interrupt Vector Table
                                   (0073) ;-----------------------------------------------------------------------------
                                   (0074) ;
                                   (0075) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                   (0076) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                   (0077) ; very short ISRs could be encoded within the table itself. Normally,
                                   (0078) ; vector jump targets are modified automatically according to the user
                                   (0079) ; modules selected. This occurs when the 'Generate Application' opera-
                                   (0080) ; tion is run causing PSoC Designer to create boot.asm and the other
                                   (0081) ; configuration files. If you need to hard code a vector, update the
                                   (0082) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0083) ; of this file.
                                   (0084) ;-----------------------------------------------------------------------------
                                   (0085) 
                                   (0086)     AREA TOP (ROM, ABS, CON)
                                   (0087) 
                                   (0088)     org   0                        ;Reset Interrupt Vector
                                   (0089)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0090) 
                                   (0091)     org   04h                      ;Supply Monitor Interrupt Vector
0004: 30       HALT                (0092)     halt                           ;Stop execution if power falls too low
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0093) 
                                   (0094)     org   08h                      ;Analog Column 0 Interrupt Vector
                                   (0095)     // call	void_handler
0008: 7E       RETI                (0096)     reti
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0097) 
                                   (0098)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                   (0099)     // call	void_handler
000C: 7E       RETI                (0100)     reti
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
0010: 30       HALT  
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
0014: 30       HALT  
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0101) 
                                   (0102)     org   18h                      ;VC3 Interrupt Vector
                                   (0103)     // call	void_handler
0018: 7E       RETI                (0104)     reti
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0105) 
                                   (0106)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0107)     // call	void_handler
001C: 7E       RETI                (0108)     reti
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0109) 
                                   (0110)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
0020: 7D 07 45 LJMP  0x0745        (0111)     ljmp	_ADCINC12_1_TMR_ISR
0023: 7E       RETI                (0112)     reti
                                   (0113) 
                                   (0114)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
0024: 7D 07 42 LJMP  0x0742        (0115)     ljmp	_ADCINC12_1_CNT_ISR
0027: 7E       RETI                (0116)     reti
                                   (0117) 
                                   (0118)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
0028: 7D 03 B0 LJMP  0x03B0        (0119)     ljmp	_LED7SEG_1_ISR
002B: 7E       RETI                (0120)     reti
                                   (0121) 
                                   (0122)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 07 B9 LJMP  _Counter8_1_ISR(0123)     ljmp	_Counter8_1_ISR
002F: 7E       RETI                (0124)     reti
0030: 30       HALT  
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
0034: 30       HALT  
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
0038: 30       HALT  
0039: 30       HALT  
003A: 30       HALT  
003B: 30       HALT  
003C: 30       HALT  
003D: 30       HALT  
003E: 30       HALT  
003F: 30       HALT  
                                   (0125) 
                                   (0126)     org   40h                      ;USB Reset Interrupt Vector
                                   (0127)     // call	void_handler
0040: 7E       RETI                (0128)     reti
0041: 30       HALT  
0042: 30       HALT  
0043: 30       HALT  
                                   (0129) 
                                   (0130)     org   44h                      ;USB SOF Interrupt Vector
                                   (0131)     // call	void_handler
0044: 7E       RETI                (0132)     reti
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0133) 
                                   (0134)     org   48h                      ;USB EP0 Interrupt Vector
                                   (0135)     // call	void_handler
0048: 7E       RETI                (0136)     reti
0049: 30       HALT  
004A: 30       HALT  
004B: 30       HALT  
                                   (0137) 
                                   (0138)     org   4Ch                      ;USB EP1 Interrupt Vector
                                   (0139)     // call	void_handler
004C: 7E       RETI                (0140)     reti
004D: 30       HALT  
004E: 30       HALT  
004F: 30       HALT  
                                   (0141) 
                                   (0142)     org   50h                      ;USB EP2 Interrupt Vector
                                   (0143)     // call	void_handler
0050: 7E       RETI                (0144)     reti
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
                                   (0145) 
                                   (0146)     org   54h                      ;USB EP3 Interrupt Vector
                                   (0147)     // call	void_handler
0054: 7E       RETI                (0148)     reti
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
                                   (0149) 
                                   (0150)     org   58h                      ;USB EP4 Interrupt Vector
                                   (0151)     // call	void_handler
0058: 7E       RETI                (0152)     reti
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
                                   (0153) 
                                   (0154)     org   5Ch                      ;USB Wakeup Interrupt Vector
                                   (0155)     // call	void_handler
005C: 7E       RETI                (0156)     reti
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0157) 
                                   (0158)     org   60h                      ;PSoC I2C Interrupt Vector
0060: 7D 05 62 LJMP  0x0562        (0159)     ljmp	_I2CHW_1_ISR
0063: 7E       RETI                (0160)     reti
                                   (0161) 
                                   (0162)     org   64h                      ;Sleep Timer Interrupt Vector
                                   (0163)     // call	void_handler
0064: 7E       RETI                (0164)     reti
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0165) 
                                   (0166) ;-----------------------------------------------------------------------------
                                   (0167) ;  Start of Execution.
                                   (0168) ;-----------------------------------------------------------------------------
                                   (0169) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0170) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0171) ;
                                   (0172)     org 68h
                                   (0173) __Start:
                                   (0174) 
                                   (0175)     ; initialize values for voltage stabilization, if required,
                                   (0176)     ; leaving power-on reset (POR) level at the default (low) level, at
                                   (0177)     ; least for now. 
                                   (0178)     ;
0068: 71 10    OR    F,16          (0179)     M8C_SetBank1
006A: 62 E3 07 MOV   REG[227],7    (0180)     mov   reg[VLT_CR], LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,239         (0181)     M8C_SetBank0
                                   (0182) 
                                   (0183)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
006F: 50 20    MOV   A,32          (0184)     mov   A, 20h
0071: 28       ROMX                (0185)     romx
                                   (0186)     ; %45%20%46%46% End workaround
                                   (0187) 	
                                   (0188) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0189)     M8C_EnableWatchDog
                                   (0190) ENDIF
                                   (0191) 
0072: 41 FE FB AND   REG[254],251  (0192)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0193) 
                                   (0194)     ;---------------------------
                                   (0195)     ; Set up the Temporary stack
                                   (0196)     ;---------------------------
                                   (0197)     ; A temporary stack is set up for the SSC instructions.
                                   (0198)     ; The real stack start will be assigned later.
                                   (0199)     ;
                                   (0200) _stack_start:          equ 80h
0075: 50 80    MOV   A,128         (0201)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0077: 4E       SWAP  SP,A          (0202)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0203) 
                                   (0204)     ;------------------------
                                   (0205)     ; Set Power-related Trim 
                                   (0206)     ;------------------------
                                   (0207) 
                                   (0208) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                   (0209) 
                                   (0210)   IF ( AGND_BYPASS )
                                   (0211)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0212)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0213)     ; bit in the write-only BDG_TR register. Recalculate the register
                                   (0214)     ; value using the proper trim values.
                                   (0215)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0216)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0217)   ENDIF
                                   (0218) ELSE
                                   (0219) 	; 3.3V operation trim codes
                                   (0220) 	; Set the IMO and Bandgap trims for 3v operation
                                   (0221)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGN_BYPASS_JUST
                                   (0222) 	
                                   (0223) 	; Set the IMO Gain Trim for 3v operation
                                   (0224) 	M8SSC_SetTableIMOGainTrim 2, SSCTBL2_TRIM_IMO_GAIN_3V
                                   (0225) 
                                   (0226) ENDIF ; 3.3 Volt Operation
                                   (0227) 
0078: 55 F8 00 MOV   [248],0       (0228)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
007B: 55 F9 00 MOV   [249],0       (0229)     mov  [bSSC_KEYSP], 0
                                   (0230) 				
                                   (0231)     ;---------------------------------------
                                   (0232)     ; Initialize Crystal Oscillator and PLL
                                   (0233)     ;---------------------------------------
                                   (0234) 
                                   (0235)     ; Either no ECO, or waiting for stable clock is to be done in main
007E: 71 10    OR    F,16          (0236)     M8C_SetBank1
0080: 62 E0 02 MOV   REG[224],2    (0237)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
0083: 70 EF    AND   F,239         (0238)     M8C_SetBank0
0085: 62 E3 38 MOV   REG[227],56   (0239)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0240) 
                                   (0241)     ;---------------------------------------------
                                   (0242)     ; Enter the Large Memory Model, if applicable
                                   (0243)     ;---------------------------------------------
                                   (0244) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0088: 62 D1 03 MOV   REG[209],3    (0245)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
008B: 50 00    MOV   A,0           (0246)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
008D: 4E       SWAP  SP,A          (0247)     swap  A, SP
008E: 62 D3 03 MOV   REG[211],3    (0248)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
0091: 62 D0 00 MOV   REG[208],0    (0249)     RAM_SETPAGE_CUR 0
0094: 62 D5 00 MOV   REG[213],0    (0250)     RAM_SETPAGE_MVW 0
0097: 62 D4 00 MOV   REG[212],0    (0251)     RAM_SETPAGE_MVR 0
                                   (0252) 
                                   (0253)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
009A: 71 C0    OR    F,192         (0254)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0255)   ELSE
                                   (0256)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0257)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0258) ELSE
                                   (0259)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                   (0260)     swap  SP, A
                                   (0261) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                   (0262) 
                                   (0263)     ;------------------------
                                   (0264)     ; Close CT leakage path.
                                   (0265)     ;------------------------
009C: 62 71 05 MOV   REG[113],5    (0266)     mov   reg[ACB00CR0], 05h
009F: 62 75 05 MOV   REG[117],5    (0267)     mov   reg[ACB01CR0], 05h
                                   (0268) 
                                   (0269)     ;-------------------------
                                   (0270)     ; Load Base Configuration
                                   (0271)     ;-------------------------
                                   (0272)     ; Load global parameter settings and load the user modules in the
                                   (0273)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0274)     ; to minimize start up time; (2) We may still need to play with the
                                   (0275)     ; Sleep Timer.
                                   (0276)     ;
00A2: 7C 03 A3 LCALL 0x03A3        (0277)     lcall LoadConfigInit
00A5: 71 10    OR    F,16          (0278) 	M8C_SetBank1
00A7: 41 E7 3F AND   REG[231],63   (0279) 	and  reg[DEC_CR1], 0x3F
00AA: 43 E7 80 OR    REG[231],128  (0280) 	or   reg[DEC_CR1], 0x80
00AD: 70 EF    AND   F,239         (0281) 	M8C_SetBank0
                                   (0282)     ;-----------------------------------
                                   (0283)     ; Initialize C Run-Time Environment
                                   (0284)     ;-----------------------------------
                                   (0285) IF ( C_LANGUAGE_SUPPORT )
                                   (0286) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                   (0287)     mov  A,0                           ; clear the 'bss' segment to zero
                                   (0288)     mov  [__r0],<__bss_start
                                   (0289) BssLoop:
                                   (0290)     cmp  [__r0],<__bss_end
                                   (0291)     jz   BssDone
                                   (0292)     mvi  [__r0],A
                                   (0293)     jmp  BssLoop
                                   (0294) BssDone:
                                   (0295)     mov  A,>__idata_start              ; copy idata to data segment
                                   (0296)     mov  X,<__idata_start
                                   (0297)     mov  [__r0],<__data_start
                                   (0298) IDataLoop:
                                   (0299)     cmp  [__r0],<__data_end
                                   (0300)     jz   C_RTE_Done
                                   (0301)     push A
                                   (0302)     romx
                                   (0303)     mvi  [__r0],A
                                   (0304)     pop  A
                                   (0305)     inc  X
                                   (0306)     adc  A,0
                                   (0307)     jmp  IDataLoop
                                   (0308) 
                                   (0309) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0310) 
                                   (0311) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00AF: 62 D0 01 MOV   REG[208],1    (0312)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0313)                                        ; to use the Virtual Register page.
                                   (0314) 
                                   (0315)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0316)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0317)     ; text segment and may have been relocated by the Code Compressor.
                                   (0318)     ;
00B2: 50 01    MOV   A,1           (0319)     mov   A, >__pXIData                ; Get the address of the flash
00B4: 57 A0    MOV   X,160         (0320)     mov   X, <__pXIData                ;   pointer to the xidata area.
00B6: 08       PUSH  A             (0321)     push  A
00B7: 28       ROMX                (0322)     romx                               ; get the MSB of xidata's address
00B8: 53 0E    MOV   [__r0],A      (0323)     mov   [__r0], A
00BA: 18       POP   A             (0324)     pop   A
00BB: 75       INC   X             (0325)     inc   X
00BC: 09 00    ADC   A,0           (0326)     adc   A, 0
00BE: 28       ROMX                (0327)     romx                               ; get the LSB of xidata's address
00BF: 4B       SWAP  A,X           (0328)     swap  A, X
00C0: 51 0E    MOV   A,[14]        (0329)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0330)                                        ;   XIData structure list in flash
00C2: 80 04    JMP   0x00C7        (0331)     jmp   .AccessStruct
                                   (0332) 
                                   (0333)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0334)     ; values of C variables. Each structure contains 3 member elements.
                                   (0335)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0336)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0337)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0338)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0339)     ; value in the second member element, an unsigned byte:
                                   (0340)     ; (1) If the value of the second element is non-zero, it represents
                                   (0341)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0342)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0343)     ; the bytes are copied to the block of RAM.
                                   (0344)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0345)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0346)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0347) 
                                   (0348) .AccessNextStructLoop:
00C4: 75       INC   X             (0349)     inc   X                            ; pXIData++
00C5: 09 00    ADC   A,0           (0350)     adc   A, 0
                                   (0351) .AccessStruct:                         ; Entry point for first block
                                   (0352)     ;
                                   (0353)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0354)     ;
00C7: 62 E3 00 MOV   REG[227],0    (0355)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00CA: 08       PUSH  A             (0356)     push  A
00CB: 28       ROMX                (0357)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00CC: 60 D5    MOV   REG[213],A    (0358)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00CE: 74       INC   A             (0359)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00CF: A0 4B    JZ    0x011B        (0360)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00D1: 18       POP   A             (0361)     pop   A                            ; restore pXIData to [A,X]
00D2: 75       INC   X             (0362)     inc   X                            ; pXIData++
00D3: 09 00    ADC   A,0           (0363)     adc   A, 0
00D5: 08       PUSH  A             (0364)     push  A
00D6: 28       ROMX                (0365)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00D7: 53 0E    MOV   [__r0],A      (0366)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00D9: 18       POP   A             (0367)     pop   A                            ; restore pXIData to [A,X]
00DA: 75       INC   X             (0368)     inc   X                            ; pXIData++ (point to size)
00DB: 09 00    ADC   A,0           (0369)     adc   A, 0
00DD: 08       PUSH  A             (0370)     push  A
00DE: 28       ROMX                (0371)     romx                               ; Get the size (CPU.A <- *pXIData)
00DF: A0 1C    JZ    0x00FC        (0372)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00E1: 53 0D    MOV   [__r1],A      (0373)     mov   [__r1], A                    ;             else downcount in __r1
00E3: 18       POP   A             (0374)     pop   A                            ; restore pXIData to [A,X]
                                   (0375) 
                                   (0376) .CopyNextByteLoop:
                                   (0377)     ; For each byte in the structure's array member, copy from flash to RAM.
                                   (0378)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                   (0379)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                   (0380)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0381)     ;
00E4: 75       INC   X             (0382)     inc   X                            ; pXIData++ (point to next data byte)
00E5: 09 00    ADC   A,0           (0383)     adc   A, 0
00E7: 08       PUSH  A             (0384)     push  A
00E8: 28       ROMX                (0385)     romx                               ; Get the data value (CPU.A <- *pXIData)
00E9: 3F 0E    MVI   [__r0],A      (0386)     mvi   [__r0], A                    ; Transfer the data to RAM
00EB: 47 0E FF TST   [14],255      (0387)     tst   [__r0], 0xff                 ; Check for page crossing
00EE: B0 06    JNZ   0x00F5        (0388)     jnz   .CopyLoopTail                ;   No crossing, keep going
00F0: 5D D5    MOV   A,REG[213]    (0389)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00F2: 74       INC   A             (0390)     inc   A
00F3: 60 D5    MOV   REG[213],A    (0391)     mov   reg[ MVW_PP], A
                                   (0392) .CopyLoopTail:
00F5: 18       POP   A             (0393)     pop   A                            ; restore pXIData to [A,X]
00F6: 7A 0D    DEC   [__r1]        (0394)     dec   [__r1]                       ; End of this array in flash?
00F8: BF EB    JNZ   0x00E4        (0395)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
00FA: 8F C9    JMP   0x00C4        (0396)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                   (0397) 
                                   (0398) .ClearRAMBlockToZero:
00FC: 18       POP   A             (0399)     pop   A                            ; restore pXIData to [A,X]
00FD: 75       INC   X             (0400)     inc   X                            ; pXIData++ (point to next data byte)
00FE: 09 00    ADC   A,0           (0401)     adc   A, 0
0100: 08       PUSH  A             (0402)     push  A
0101: 28       ROMX                (0403)     romx                               ; Get the run length (CPU.A <- *pXIData)
0102: 53 0D    MOV   [__r1],A      (0404)     mov   [__r1], A                    ; Initialize downcounter
0104: 50 00    MOV   A,0           (0405)     mov   A, 0                         ; Initialize source data
                                   (0406) 
                                   (0407) .ClearRAMBlockLoop:
                                   (0408)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                   (0409)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0410)     ;
0106: 3F 0E    MVI   [__r0],A      (0411)     mvi   [__r0], A                    ; Clear a byte
0108: 47 0E FF TST   [14],255      (0412)     tst   [__r0], 0xff                 ; Check for page crossing
010B: B0 08    JNZ   0x0114        (0413)     jnz   .ClearLoopTail               ;   No crossing, keep going
010D: 5D D5    MOV   A,REG[213]    (0414)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
010F: 74       INC   A             (0415)     inc   A
0110: 60 D5    MOV   REG[213],A    (0416)     mov   reg[ MVW_PP], A
0112: 50 00    MOV   A,0           (0417)     mov   A, 0                         ; Restore the zero used for clearing
                                   (0418) .ClearLoopTail:
0114: 7A 0D    DEC   [__r1]        (0419)     dec   [__r1]                       ; Was this the last byte?
0116: BF EF    JNZ   0x0106        (0420)     jnz   .ClearRAMBlockLoop           ;   No,  continue
0118: 18       POP   A             (0421)     pop   A                            ;   Yes, restore pXIData to [A,X] and
0119: 8F AA    JMP   0x00C4        (0422)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                   (0423) 
                                   (0424) .C_RTE_WrapUp:
011B: 18       POP   A             (0425)     pop   A                            ; balance stack
                                   (0426) 
                                   (0427) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                   (0428) 
                                   (0429) C_RTE_Done:
                                   (0430) 
                                   (0431) ENDIF ; C_LANGUAGE_SUPPORT
                                   (0432) 
                                   (0433) 
                                   (0434)     ;-------------------------------
                                   (0435)     ; Set Power-On Reset (POR) Level
                                   (0436)     ;-------------------------------
011C: 71 10    OR    F,16          (0437)     M8C_SetBank1
                                   (0438) 
                                   (0439) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
                                   (0440)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;   Yes, change to midpoint trip
                                   (0441) ELSE										   ; 5V Operation
                                   (0442)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
011E: 43 E3 00 OR    REG[227],0    (0443)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;         No, change to midpoint trip
                                   (0444)   ELSE ; 24HMz                                 ;
                                   (0445)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
                                   (0446)   ENDIF ; 24MHz
                                   (0447) ENDIF ; 3.3V Operation
                                   (0448) 
0121: 70 EF    AND   F,239         (0449)     M8C_SetBank0
                                   (0450) 
                                   (0451)     ;----------------------------
                                   (0452)     ; Wrap up and invoke "main"
                                   (0453)     ;----------------------------
                                   (0454) 
                                   (0455)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                   (0456)     ; no interrupts should be enabled now, so may as well clear the register.
                                   (0457)     ;
0123: 62 E0 00 MOV   REG[224],0    (0458)     mov  reg[INT_MSK0],0
                                   (0459) 
                                   (0460)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                   (0461)     ;
0126: 71 10    OR    F,16          (0462)     M8C_SetBank1
0128: 62 E0 02 MOV   REG[224],2    (0463)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
012B: 70 EF    AND   F,239         (0464)     M8C_SetBank0
                                   (0465) 
                                   (0466)     ; Global Interrupt are NOT enabled, this should be done in main().
                                   (0467)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                   (0468)     ; Global Interrupts should be enabled as soon as possible in main().
                                   (0469)     ;
012D: 62 E2 00 MOV   REG[226],0    (0470)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                   (0471)                                    ; have been set during the boot process.
                                   (0472) IF ENABLE_LJMP_TO_MAIN
                                   (0473)     ljmp  _main                    ; goto main (no return)
                                   (0474) ELSE
0130: 7C 08 D3 LCALL _main         (0475)     lcall _main                    ; call main
                                   (0476) .Exit:
0133: 8F FF    JMP   0x0133        (0477)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                   (0478) ENDIF
                                   (0479) 
                                   (0480)     ;---------------------------------
                                   (0481)     ; Library Access to Global Parms
                                   (0482)     ;---------------------------------
                                   (0483)     ;
                                   (0484)  bGetPowerSetting:
                                   (0485) _bGetPowerSetting:
                                   (0486)     ; Returns value of POWER_SETTING in the A register.
                                   (0487)     ; No inputs. No Side Effects.
                                   (0488)     ;
0135: 50 10    MOV   A,16          (0489)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
0137: 7F       RET                 (0490)     ret
0138: 30       HALT  
0139: 30       HALT  
013A: 30       HALT  
013B: 30       HALT  
013C: 30       HALT  
013D: 30       HALT  
013E: 30       HALT  
013F: 30       HALT  
0140: 30       HALT  
0141: 30       HALT  
0142: 30       HALT  
0143: 30       HALT  
0144: 30       HALT  
0145: 30       HALT  
0146: 30       HALT  
0147: 30       HALT  
0148: 30       HALT  
0149: 30       HALT  
014A: 30       HALT  
014B: 30       HALT  
014C: 30       HALT  
014D: 30       HALT  
014E: 30       HALT  
014F: 30       HALT  
0150: 30       HALT  
0151: 30       HALT  
0152: 30       HALT  
0153: 30       HALT  
0154: 30       HALT  
0155: 30       HALT  
0156: 30       HALT  
0157: 30       HALT  
0158: 30       HALT  
0159: 30       HALT  
015A: 30       HALT  
015B: 30       HALT  
015C: 30       HALT  
015D: 30       HALT  
015E: 30       HALT  
015F: 30       HALT  
0160: 30       HALT  
0161: 30       HALT  
0162: 30       HALT  
0163: 30       HALT  
0164: 30       HALT  
0165: 30       HALT  
0166: 30       HALT  
0167: 30       HALT  
0168: 30       HALT  
0169: 30       HALT  
016A: 30       HALT  
016B: 30       HALT  
016C: 30       HALT  
016D: 30       HALT  
016E: 30       HALT  
016F: 30       HALT  
0170: 30       HALT  
0171: 30       HALT  
0172: 30       HALT  
0173: 30       HALT  
0174: 30       HALT  
0175: 30       HALT  
0176: 30       HALT  
0177: 30       HALT  
0178: 30       HALT  
0179: 30       HALT  
017A: 30       HALT  
017B: 30       HALT  
017C: 30       HALT  
017D: 30       HALT  
017E: 30       HALT  
017F: 30       HALT  
0180: 30       HALT  
0181: 30       HALT  
0182: 30       HALT  
0183: 30       HALT  
0184: 30       HALT  
0185: 30       HALT  
0186: 30       HALT  
0187: 30       HALT  
0188: 30       HALT  
0189: 30       HALT  
018A: 30       HALT  
018B: 30       HALT  
018C: 30       HALT  
018D: 30       HALT  
018E: 30       HALT  
018F: 30       HALT  
0190: 30       HALT  
0191: 30       HALT  
0192: 30       HALT  
0193: 30       HALT  
0194: 30       HALT  
0195: 30       HALT  
0196: 30       HALT  
0197: 30       HALT  
0198: 30       HALT  
0199: 30       HALT  
019A: 30       HALT  
019B: 30       HALT  
019C: 30       HALT  
019D: 30       HALT  
019E: 30       HALT  
019F: 30       HALT  
01A0: 0D A2    ADC   [X-94],A

FILE: lib\psocconfigtbl.asm
                                   (0001) ; Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0002) ;
                                   (0003) include "m8c.inc"
                                   (0004) ;  Personalization tables 
                                   (0005) export LoadConfigTBL_radyopnl
                                   (0006) AREA psoc_config(rom, rel)
                                   (0007) LoadConfigTBL_radyopnl:
                                   (0008) ;  Ordered Global Register values
01A2: 71 10    OR    F,16          (0009) 	M8C_SetBank1
01A4: 62 00 00 MOV   REG[0],0      (0010) 	mov	reg[00h], 00h		; Port_0_DriveMode_0 register (PRT0DM0)
01A7: 62 01 FF MOV   REG[1],255    (0011) 	mov	reg[01h], ffh		; Port_0_DriveMode_1 register (PRT0DM1)
01AA: 70 EF    AND   F,239         (0012) 	M8C_SetBank0
01AC: 62 03 FF MOV   REG[3],255    (0013) 	mov	reg[03h], ffh		; Port_0_DriveMode_2 register (PRT0DM2)
01AF: 62 02 00 MOV   REG[2],0      (0014) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
01B2: 71 10    OR    F,16          (0015) 	M8C_SetBank1
01B4: 62 02 00 MOV   REG[2],0      (0016) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
01B7: 62 03 00 MOV   REG[3],0      (0017) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
01BA: 70 EF    AND   F,239         (0018) 	M8C_SetBank0
01BC: 62 01 00 MOV   REG[1],0      (0019) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
01BF: 71 10    OR    F,16          (0020) 	M8C_SetBank1
01C1: 62 04 A0 MOV   REG[4],160    (0021) 	mov	reg[04h], a0h		; Port_1_DriveMode_0 register (PRT1DM0)
01C4: 62 05 FF MOV   REG[5],255    (0022) 	mov	reg[05h], ffh		; Port_1_DriveMode_1 register (PRT1DM1)
01C7: 70 EF    AND   F,239         (0023) 	M8C_SetBank0
01C9: 62 07 FF MOV   REG[7],255    (0024) 	mov	reg[07h], ffh		; Port_1_DriveMode_2 register (PRT1DM2)
01CC: 62 06 00 MOV   REG[6],0      (0025) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
01CF: 71 10    OR    F,16          (0026) 	M8C_SetBank1
01D1: 62 06 00 MOV   REG[6],0      (0027) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
01D4: 62 07 00 MOV   REG[7],0      (0028) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
01D7: 70 EF    AND   F,239         (0029) 	M8C_SetBank0
01D9: 62 05 00 MOV   REG[5],0      (0030) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
01DC: 71 10    OR    F,16          (0031) 	M8C_SetBank1
01DE: 62 08 00 MOV   REG[8],0      (0032) 	mov	reg[08h], 00h		; Port_2_DriveMode_0 register (PRT2DM0)
01E1: 62 09 FF MOV   REG[9],255    (0033) 	mov	reg[09h], ffh		; Port_2_DriveMode_1 register (PRT2DM1)
01E4: 70 EF    AND   F,239         (0034) 	M8C_SetBank0
01E6: 62 0B 3F MOV   REG[11],63    (0035) 	mov	reg[0bh], 3fh		; Port_2_DriveMode_2 register (PRT2DM2)
01E9: 62 0A 00 MOV   REG[10],0     (0036) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
01EC: 71 10    OR    F,16          (0037) 	M8C_SetBank1
01EE: 62 0A 00 MOV   REG[10],0     (0038) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
01F1: 62 0B 00 MOV   REG[11],0     (0039) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
01F4: 70 EF    AND   F,239         (0040) 	M8C_SetBank0
01F6: 62 09 00 MOV   REG[9],0      (0041) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
01F9: 71 10    OR    F,16          (0042) 	M8C_SetBank1
01FB: 62 0C 00 MOV   REG[12],0     (0043) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
01FE: 62 0D FF MOV   REG[13],255   (0044) 	mov	reg[0dh], ffh		; Port_3_DriveMode_1 register (PRT3DM1)
0201: 70 EF    AND   F,239         (0045) 	M8C_SetBank0
0203: 62 0F F0 MOV   REG[15],240   (0046) 	mov	reg[0fh], f0h		; Port_3_DriveMode_2 register (PRT3DM2)
0206: 62 0E 00 MOV   REG[14],0     (0047) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
0209: 71 10    OR    F,16          (0048) 	M8C_SetBank1
020B: 62 0E 00 MOV   REG[14],0     (0049) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
020E: 62 0F 00 MOV   REG[15],0     (0050) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
0211: 70 EF    AND   F,239         (0051) 	M8C_SetBank0
0213: 62 0D 00 MOV   REG[13],0     (0052) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
0216: 71 10    OR    F,16          (0053) 	M8C_SetBank1
0218: 62 10 00 MOV   REG[16],0     (0054) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
021B: 62 11 FD MOV   REG[17],253   (0055) 	mov	reg[11h], fdh		; Port_4_DriveMode_1 register (PRT4DM1)
021E: 70 EF    AND   F,239         (0056) 	M8C_SetBank0
0220: 62 13 FD MOV   REG[19],253   (0057) 	mov	reg[13h], fdh		; Port_4_DriveMode_2 register (PRT4DM2)
0223: 62 12 00 MOV   REG[18],0     (0058) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
0226: 71 10    OR    F,16          (0059) 	M8C_SetBank1
0228: 62 12 00 MOV   REG[18],0     (0060) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
022B: 62 13 00 MOV   REG[19],0     (0061) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
022E: 70 EF    AND   F,239         (0062) 	M8C_SetBank0
0230: 62 11 00 MOV   REG[17],0     (0063) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
0233: 71 10    OR    F,16          (0064) 	M8C_SetBank1
0235: 62 14 FF MOV   REG[20],255   (0065) 	mov	reg[14h], ffh		; Port_5_DriveMode_0 register (PRT5DM0)
0238: 62 15 00 MOV   REG[21],0     (0066) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
023B: 70 EF    AND   F,239         (0067) 	M8C_SetBank0
023D: 62 17 00 MOV   REG[23],0     (0068) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
0240: 62 16 00 MOV   REG[22],0     (0069) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
0243: 71 10    OR    F,16          (0070) 	M8C_SetBank1
0245: 62 16 00 MOV   REG[22],0     (0071) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
0248: 62 17 00 MOV   REG[23],0     (0072) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
024B: 70 EF    AND   F,239         (0073) 	M8C_SetBank0
024D: 62 15 00 MOV   REG[21],0     (0074) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
0250: 71 10    OR    F,16          (0075) 	M8C_SetBank1
0252: 62 1C 00 MOV   REG[28],0     (0076) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
0255: 62 1D 81 MOV   REG[29],129   (0077) 	mov	reg[1dh], 81h		; Port_7_DriveMode_1 register (PRT7DM1)
0258: 70 EF    AND   F,239         (0078) 	M8C_SetBank0
025A: 62 1F 00 MOV   REG[31],0     (0079) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
025D: 62 1E 00 MOV   REG[30],0     (0080) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
0260: 71 10    OR    F,16          (0081) 	M8C_SetBank1
0262: 62 1E 00 MOV   REG[30],0     (0082) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
0265: 62 1F 00 MOV   REG[31],0     (0083) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
0268: 70 EF    AND   F,239         (0084) 	M8C_SetBank0
026A: 62 1D 00 MOV   REG[29],0     (0085) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
026D: 70 EF    AND   F,239         (0086) 	M8C_SetBank0
                                   (0087) ;  Global Register values
026F: 62 60 08 MOV   REG[96],8     (0088) 	mov	reg[60h], 08h		; AnalogColumnInputSelect register (AMX_IN)
0272: 62 66 00 MOV   REG[102],0    (0089) 	mov	reg[66h], 00h		; AnalogComparatorControl1 register (CMP_CR1)
0275: 62 61 C0 MOV   REG[97],192   (0090) 	mov	reg[61h], c0h		; AnalogMuxBusConfig register (AMUXCFG)
0278: 62 63 05 MOV   REG[99],5     (0091) 	mov	reg[63h], 05h		; AnalogReferenceControl register (ARF_CR)
027B: 62 65 00 MOV   REG[101],0    (0092) 	mov	reg[65h], 00h		; AnalogSyncControl register (ASY_CR)
027E: 62 FD 00 MOV   REG[253],0    (0093) 	mov	reg[fdh], 00h		; DAC_Data register (DAC_D)
0281: 62 E6 00 MOV   REG[230],0    (0094) 	mov	reg[e6h], 00h		; DecimatorControl_0 register (DEC_CR0)
0284: 62 E7 03 MOV   REG[231],3    (0095) 	mov	reg[e7h], 03h		; DecimatorControl_1 register (DEC_CR1)
0287: 62 56 00 MOV   REG[86],0     (0096) 	mov	reg[56h], 00h		; Endpoint0Control register (EP0_CR)
028A: 62 57 00 MOV   REG[87],0     (0097) 	mov	reg[57h], 00h		; Endpoint0Count register (EP0_CNT)
028D: 62 58 00 MOV   REG[88],0     (0098) 	mov	reg[58h], 00h		; Endpoint0Data0 register (EP0_DR0)
0290: 62 59 00 MOV   REG[89],0     (0099) 	mov	reg[59h], 00h		; Endpoint0Data1 register (EP0_DR1)
0293: 62 5A 00 MOV   REG[90],0     (0100) 	mov	reg[5ah], 00h		; Endpoint0Data2 register (EP0_DR2)
0296: 62 5B 00 MOV   REG[91],0     (0101) 	mov	reg[5bh], 00h		; Endpoint0Data3 register (EP0_DR3)
0299: 62 5C 00 MOV   REG[92],0     (0102) 	mov	reg[5ch], 00h		; Endpoint0Data4 register (EP0_DR4)
029C: 62 5D 00 MOV   REG[93],0     (0103) 	mov	reg[5dh], 00h		; Endpoint0Data5 register (EP0_DR5)
029F: 62 5E 00 MOV   REG[94],0     (0104) 	mov	reg[5eh], 00h		; Endpoint0Data6 register (EP0_DR6)
02A2: 62 5F 00 MOV   REG[95],0     (0105) 	mov	reg[5fh], 00h		; Endpoint0Data7 register (EP0_DR7)
02A5: 62 4F 00 MOV   REG[79],0     (0106) 	mov	reg[4fh], 00h		; Endpoint1Count0 register (EP1_CNT)
02A8: 62 4E 00 MOV   REG[78],0     (0107) 	mov	reg[4eh], 00h		; Endpoint1Count1 register (EP1_CNT1)
02AB: 62 51 00 MOV   REG[81],0     (0108) 	mov	reg[51h], 00h		; Endpoint2Count0 register (EP2_CNT)
02AE: 62 50 00 MOV   REG[80],0     (0109) 	mov	reg[50h], 00h		; Endpoint2Count1 register (EP2_CNT1)
02B1: 62 53 00 MOV   REG[83],0     (0110) 	mov	reg[53h], 00h		; Endpoint3Count0 register (EP3_CNT)
02B4: 62 52 00 MOV   REG[82],0     (0111) 	mov	reg[52h], 00h		; Endpoint3Count1 register (EP3_CNT1)
02B7: 62 55 00 MOV   REG[85],0     (0112) 	mov	reg[55h], 00h		; Endpoint4Count0 register (EP4_CNT)
02BA: 62 54 00 MOV   REG[84],0     (0113) 	mov	reg[54h], 00h		; Endpoint4Count1 register (EP4_CNT1)
02BD: 62 D6 04 MOV   REG[214],4    (0114) 	mov	reg[d6h], 04h		; I2CConfig register (I2CCFG)
02C0: 62 B0 00 MOV   REG[176],0    (0115) 	mov	reg[b0h], 00h		; Row_0_InputMux register (RDI0RI)
02C3: 62 B1 00 MOV   REG[177],0    (0116) 	mov	reg[b1h], 00h		; Row_0_InputSync register (RDI0SYN)
02C6: 62 B2 00 MOV   REG[178],0    (0117) 	mov	reg[b2h], 00h		; Row_0_LogicInputAMux register (RDI0IS)
02C9: 62 B3 33 MOV   REG[179],51   (0118) 	mov	reg[b3h], 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
02CC: 62 B4 33 MOV   REG[180],51   (0119) 	mov	reg[b4h], 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
02CF: 62 B5 00 MOV   REG[181],0    (0120) 	mov	reg[b5h], 00h		; Row_0_OutputDrive_0 register (RDI0SRO0)
02D2: 62 B6 00 MOV   REG[182],0    (0121) 	mov	reg[b6h], 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
02D5: 62 4A 00 MOV   REG[74],0     (0122) 	mov	reg[4ah], 00h		; USBControl_0 register (USB_CR0)
02D8: 62 4B 00 MOV   REG[75],0     (0123) 	mov	reg[4bh], 00h		; USBIOControl_0 register (USBIO_CR0)
02DB: 62 4C 00 MOV   REG[76],0     (0124) 	mov	reg[4ch], 00h		; USBIOControl_1 register (USBIO_CR1)
                                   (0125) ;  Instance name ADCINC12_1, User Module ADCINC12
                                   (0126) ;       Instance name ADCINC12_1, Block Name ADC(ASC10)
02DE: 62 80 90 MOV   REG[128],144  (0127) 	mov	reg[80h], 90h		;ADCINC12_1_AtoDcr0(ASC10CR0)
02E1: 62 81 00 MOV   REG[129],0    (0128) 	mov	reg[81h], 00h		;ADCINC12_1_AtoDcr1(ASC10CR1)
02E4: 62 82 60 MOV   REG[130],96   (0129) 	mov	reg[82h], 60h		;ADCINC12_1_AtoDcr2(ASC10CR2)
02E7: 62 83 F0 MOV   REG[131],240  (0130) 	mov	reg[83h], f0h		;ADCINC12_1_AtoDcr3(ASC10CR3)
                                   (0131) ;       Instance name ADCINC12_1, Block Name CNT(DBB01)
02EA: 62 27 00 MOV   REG[39],0     (0132) 	mov	reg[27h], 00h		;ADCINC12_1_CounterCR0(DBB01CR0)
02ED: 62 25 00 MOV   REG[37],0     (0133) 	mov	reg[25h], 00h		;ADCINC12_1_CounterDR1(DBB01DR1)
02F0: 62 26 00 MOV   REG[38],0     (0134) 	mov	reg[26h], 00h		;ADCINC12_1_CounterDR2(DBB01DR2)
                                   (0135) ;       Instance name ADCINC12_1, Block Name TMR(DBB00)
02F3: 62 23 00 MOV   REG[35],0     (0136) 	mov	reg[23h], 00h		;ADCINC12_1_TimerCR0(DBB00CR0)
02F6: 62 21 00 MOV   REG[33],0     (0137) 	mov	reg[21h], 00h		;ADCINC12_1_TimerDR1(DBB00DR1)
02F9: 62 22 00 MOV   REG[34],0     (0138) 	mov	reg[22h], 00h		;ADCINC12_1_TimerDR2(DBB00DR2)
                                   (0139) ;  Instance name AMUX8_1, User Module AMUX8
                                   (0140) ;  Instance name Counter8_1, User Module Counter8
                                   (0141) ;       Instance name Counter8_1, Block Name CNTR8(DCB03)
02FC: 62 2F 00 MOV   REG[47],0     (0142) 	mov	reg[2fh], 00h		;Counter8_1_CONTROL_REG(DCB03CR0)
02FF: 62 2D FF MOV   REG[45],255   (0143) 	mov	reg[2dh], ffh		;Counter8_1_PERIOD_REG(DCB03DR1)
0302: 62 2E 80 MOV   REG[46],128   (0144) 	mov	reg[2eh], 80h		;Counter8_1_COMPARE_REG(DCB03DR2)
                                   (0145) ;  Instance name I2CHW_1, User Module I2CHW
                                   (0146) ;  Instance name LED7SEG_1, User Module LED7SEG
                                   (0147) ;       Instance name LED7SEG_1, Block Name MPXTMR(DCB02)
0305: 62 2B 04 MOV   REG[43],4     (0148) 	mov	reg[2bh], 04h		;LED7SEG_1_CONTROL_REG(DCB02CR0)
0308: 62 29 3F MOV   REG[41],63    (0149) 	mov	reg[29h], 3fh		;LED7SEG_1_(DCB02DR1)
030B: 62 2A 15 MOV   REG[42],21    (0150) 	mov	reg[2ah], 15h		;LED7SEG_1_(DCB02DR2)
                                   (0151) ;  Instance name PGA_1, User Module PGA
                                   (0152) ;       Instance name PGA_1, Block Name GAIN(ACB00)
030E: 62 71 FE MOV   REG[113],254  (0153) 	mov	reg[71h], feh		;PGA_1_GAIN_CR0(ACB00CR0)
0311: 62 72 21 MOV   REG[114],33   (0154) 	mov	reg[72h], 21h		;PGA_1_GAIN_CR1(ACB00CR1)
0314: 62 73 20 MOV   REG[115],32   (0155) 	mov	reg[73h], 20h		;PGA_1_GAIN_CR2(ACB00CR2)
0317: 62 70 00 MOV   REG[112],0    (0156) 	mov	reg[70h], 00h		;PGA_1_GAIN_CR3(ACB00CR3)
031A: 71 10    OR    F,16          (0157) 	M8C_SetBank1
                                   (0158) ;  Global Register values
031C: 62 61 00 MOV   REG[97],0     (0159) 	mov	reg[61h], 00h		; AnalogClockSelect1 register (CLK_CR1)
031F: 62 69 00 MOV   REG[105],0    (0160) 	mov	reg[69h], 00h		; AnalogClockSelect2 register (CLK_CR2)
0322: 62 60 01 MOV   REG[96],1     (0161) 	mov	reg[60h], 01h		; AnalogColumnClockSelect register (CLK_CR0)
0325: 62 62 00 MOV   REG[98],0     (0162) 	mov	reg[62h], 00h		; AnalogIOControl_0 register (ABF_CR0)
0328: 62 67 33 MOV   REG[103],51   (0163) 	mov	reg[67h], 33h		; AnalogLUTControl0 register (ALT_CR0)
032B: 62 68 00 MOV   REG[104],0    (0164) 	mov	reg[68h], 00h		; AnalogLUTControl1 register (ALT_CR1)
032E: 62 63 00 MOV   REG[99],0     (0165) 	mov	reg[63h], 00h		; AnalogModulatorControl_0 register (AMD_CR0)
0331: 62 66 00 MOV   REG[102],0    (0166) 	mov	reg[66h], 00h		; AnalogModulatorControl_1 register (AMD_CR1)
0334: 62 64 00 MOV   REG[100],0    (0167) 	mov	reg[64h], 00h		; ComparatorGlobalOutEn register (CMP_GO_EN)
0337: 62 64 00 MOV   REG[100],0    (0168) 	mov	reg[64h], 00h		; ComparatorGlobalOutEn1 register (CMP_GO_EN1)
033A: 62 FD 80 MOV   REG[253],128  (0169) 	mov	reg[fdh], 80h		; DAC_Control register (DAC_CR)
033D: 62 C4 00 MOV   REG[196],0    (0170) 	mov	reg[c4h], 00h		; Endpoint1Control register (EP1_CR)
0340: 62 C5 00 MOV   REG[197],0    (0171) 	mov	reg[c5h], 00h		; Endpoint2Control register (EP2_CR)
0343: 62 C6 00 MOV   REG[198],0    (0172) 	mov	reg[c6h], 00h		; Endpoint3Control register (EP3_CR)
0346: 62 C7 00 MOV   REG[199],0    (0173) 	mov	reg[c7h], 00h		; Endpoint4Control register (EP4_CR)
0349: 62 D1 00 MOV   REG[209],0    (0174) 	mov	reg[d1h], 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
034C: 62 D3 00 MOV   REG[211],0    (0175) 	mov	reg[d3h], 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
034F: 62 D0 00 MOV   REG[208],0    (0176) 	mov	reg[d0h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
0352: 62 D2 00 MOV   REG[210],0    (0177) 	mov	reg[d2h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
0355: 62 E1 F0 MOV   REG[225],240  (0178) 	mov	reg[e1h], f0h		; OscillatorControl_1 register (OSC_CR1)
0358: 62 E2 00 MOV   REG[226],0    (0179) 	mov	reg[e2h], 00h		; OscillatorControl_2 register (OSC_CR2)
035B: 62 DF 09 MOV   REG[223],9    (0180) 	mov	reg[dfh], 09h		; OscillatorControl_3 register (OSC_CR3)
035E: 62 DE 00 MOV   REG[222],0    (0181) 	mov	reg[deh], 00h		; OscillatorControl_4 register (OSC_CR4)
0361: 62 DD 00 MOV   REG[221],0    (0182) 	mov	reg[ddh], 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
0364: 62 D8 00 MOV   REG[216],0    (0183) 	mov	reg[d8h], 00h		; Port_0_MUXBusCtrl register (MUX_CR0)
0367: 62 D9 00 MOV   REG[217],0    (0184) 	mov	reg[d9h], 00h		; Port_1_MUXBusCtrl register (MUX_CR1)
036A: 62 DA 00 MOV   REG[218],0    (0185) 	mov	reg[dah], 00h		; Port_2_MUXBusCtrl register (MUX_CR2)
036D: 62 DB 00 MOV   REG[219],0    (0186) 	mov	reg[dbh], 00h		; Port_3_MUXBusCtrl register (MUX_CR3)
0370: 62 EC 00 MOV   REG[236],0    (0187) 	mov	reg[ech], 00h		; Port_4_MUXBusCtrl register (MUX_CR4)
0373: 62 ED 00 MOV   REG[237],0    (0188) 	mov	reg[edh], 00h		; Port_5_MUXBusCtrl register (MUX_CR5)
0376: 62 E7 00 MOV   REG[231],0    (0189) 	mov	reg[e7h], 00h		; Type2Decimator_Control register (DEC_CR2)
0379: 62 C1 00 MOV   REG[193],0    (0190) 	mov	reg[c1h], 00h		; USBControl_1 register (USB_CR1)
                                   (0191) ;  Instance name ADCINC12_1, User Module ADCINC12
                                   (0192) ;       Instance name ADCINC12_1, Block Name ADC(ASC10)
                                   (0193) ;       Instance name ADCINC12_1, Block Name CNT(DBB01)
037C: 62 24 21 MOV   REG[36],33    (0194) 	mov	reg[24h], 21h		;ADCINC12_1_CounterFN(DBB01FN)
037F: 62 25 45 MOV   REG[37],69    (0195) 	mov	reg[25h], 45h		;ADCINC12_1_CounterSL(DBB01IN)
0382: 62 26 40 MOV   REG[38],64    (0196) 	mov	reg[26h], 40h		;ADCINC12_1_CounterOS(DBB01OU)
                                   (0197) ;       Instance name ADCINC12_1, Block Name TMR(DBB00)
0385: 62 20 20 MOV   REG[32],32    (0198) 	mov	reg[20h], 20h		;ADCINC12_1_TimerFN(DBB00FN)
0388: 62 21 15 MOV   REG[33],21    (0199) 	mov	reg[21h], 15h		;ADCINC12_1_TimerSL(DBB00IN)
038B: 62 22 40 MOV   REG[34],64    (0200) 	mov	reg[22h], 40h		;ADCINC12_1_TimerOS(DBB00OU)
                                   (0201) ;  Instance name AMUX8_1, User Module AMUX8
                                   (0202) ;  Instance name Counter8_1, User Module Counter8
                                   (0203) ;       Instance name Counter8_1, Block Name CNTR8(DCB03)
038E: 62 2C 21 MOV   REG[44],33    (0204) 	mov	reg[2ch], 21h		;Counter8_1_FUNC_REG(DCB03FN)
0391: 62 2D 11 MOV   REG[45],17    (0205) 	mov	reg[2dh], 11h		;Counter8_1_INPUT_REG(DCB03IN)
0394: 62 2E 40 MOV   REG[46],64    (0206) 	mov	reg[2eh], 40h		;Counter8_1_OUTPUT_REG(DCB03OU)
                                   (0207) ;  Instance name I2CHW_1, User Module I2CHW
                                   (0208) ;  Instance name LED7SEG_1, User Module LED7SEG
                                   (0209) ;       Instance name LED7SEG_1, Block Name MPXTMR(DCB02)
0397: 62 28 20 MOV   REG[40],32    (0210) 	mov	reg[28h], 20h		;LED7SEG_1_(DCB02FN)
039A: 62 29 17 MOV   REG[41],23    (0211) 	mov	reg[29h], 17h		;LED7SEG_1_(DCB02IN)
039D: 62 2A 40 MOV   REG[42],64    (0212) 	mov	reg[2ah], 40h		;LED7SEG_1_(DCB02OU)
                                   (0213) ;  Instance name PGA_1, User Module PGA
                                   (0214) ;       Instance name PGA_1, Block Name GAIN(ACB00)
03A0: 70 EF    AND   F,239         (0215) 	M8C_SetBank0
03A2: 7F       RET                 (0216) 	ret

FILE: lib\psocconfig.asm
                                   (0001) ; Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0002) ;
                                   (0003) ;==========================================================================
                                   (0004) ;  PSoCConfig.asm
                                   (0005) ;  @PSOC_VERSION
                                   (0006) ;
                                   (0007) ;  Version: 0.85
                                   (0008) ;  Revised: June 22, 2004
                                   (0009) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0010) ;
                                   (0011) ;  This file is generated by the Device Editor on Application Generation.
                                   (0012) ;  It contains code which loads the configuration data table generated in
                                   (0013) ;  the file PSoCConfigTBL.asm
                                   (0014) ;
                                   (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0016) ;  Edits to this file will not be preserved.
                                   (0017) ;==========================================================================
                                   (0018) ;
                                   (0019) include "m8c.inc"
                                   (0020) include "memory.inc"
                                   (0021) include "GlobalParams.inc"
                                   (0022) 
                                   (0023) export LoadConfigInit
                                   (0024) export _LoadConfigInit
                                   (0025) export LoadConfig_radyopnl
                                   (0026) export _LoadConfig_radyopnl
                                   (0027) export Port_0_Data_SHADE
                                   (0028) export _Port_0_Data_SHADE
                                   (0029) 
                                   (0030) 
                                   (0031) export NO_SHADOW
                                   (0032) export _NO_SHADOW
                                   (0033) 
                                   (0034) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                   (0035) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0036) 
                                   (0037) AREA psoc_config(rom, rel)
                                   (0038) 
                                   (0039) 
                                   (0040) ;---------------------------------------------------------------------------
                                   (0041) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                   (0042) ;                  parameters handled by boot code, like CPU speed). This
                                   (0043) ;                  function can be called from user code, but typically it
                                   (0044) ;                  is only called from boot.
                                   (0045) ;
                                   (0046) ;       INPUTS: None.
                                   (0047) ;      RETURNS: Nothing.
                                   (0048) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                   (0049) ;               In the large memory model currently only the page
                                   (0050) ;               pointer registers listed below are modified.  This does
                                   (0051) ;               not guarantee that in future implementations of this
                                   (0052) ;               function other page pointer registers will not be
                                   (0053) ;               modified.
                                   (0054) ;          
                                   (0055) ;               Page Pointer Registers Modified: 
                                   (0056) ;               CUR_PP
                                   (0057) ;
                                   (0058) _LoadConfigInit:
                                   (0059)  LoadConfigInit:
                                   (0060)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0061)     
03A3: 55 00 00 MOV   [0],0         (0062) 	mov		[Port_0_Data_SHADE], 0h
                                   (0063) 
03A6: 7C 03 AA LCALL 0x03AA        (0064) 	lcall	LoadConfig_radyopnl
                                   (0065) 
                                   (0066) 
                                   (0067)     RAM_EPILOGUE RAM_USE_CLASS_4
03A9: 7F       RET                 (0068)     ret
                                   (0069) 
                                   (0070) ;---------------------------------------------------------------------------
                                   (0071) ; Load Configuration radyopnl
                                   (0072) ;
                                   (0073) ;    Load configuration registers for radyopnl.
                                   (0074) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0075) ;
                                   (0076) ;       INPUTS: None.
                                   (0077) ;      RETURNS: Nothing.
                                   (0078) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0079) ;               modified as may the Page Pointer registers!
                                   (0080) ;               In the large memory model currently only the page
                                   (0081) ;               pointer registers listed below are modified.  This does
                                   (0082) ;               not guarantee that in future implementations of this
                                   (0083) ;               function other page pointer registers will not be
                                   (0084) ;               modified.
                                   (0085) ;          
                                   (0086) ;               Page Pointer Registers Modified: 
                                   (0087) ;               CUR_PP
                                   (0088) ;
                                   (0089) _LoadConfig_radyopnl:
                                   (0090)  LoadConfig_radyopnl:
                                   (0091)     RAM_PROLOGUE RAM_USE_CLASS_4
03AA: 7C 01 A2 LCALL 0x01A2        (0092)     lcall   LoadConfigTBL_radyopnl            ; Call load config table routine
                                   (0093) 
                                   (0094) 
03AD: 70 EF    AND   F,239         (0095)     M8C_SetBank0                    ; Force return to bank 0
                                   (0096)     RAM_EPILOGUE RAM_USE_CLASS_4
03AF: 7F       RET                 (0097)     ret

FILE: lib\led7seg_1int.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: LED7SEG_1INT.asm
                                   (0004) ;;   Version: 1.0, Updated on 2006/06/14 at 07:47:37
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: LED7SEG Interrupt Service Routine
                                   (0008) ;;-----------------------------------------------------------------------------
                                   (0009) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0010) ;;*****************************************************************************
                                   (0011) ;;*****************************************************************************
                                   (0012) 
                                   (0013) include "m8c.inc"
                                   (0014) include "memory.inc"
                                   (0015) include "LED7SEG_1.inc"
                                   (0016) 
                                   (0017) 
                                   (0018) ;-----------------------------------------------
                                   (0019) ;  Global Symbols
                                   (0020) ;-----------------------------------------------
                                   (0021) export  _LED7SEG_1_ISR
                                   (0022) 
                                   (0023) 
                                   (0024) AREA InterruptRAM (RAM,REL,CON)
                                   (0025) 
                                   (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                   (0027) ;---------------------------------------------------
                                   (0028) ; Insert your custom declarations below this banner
                                   (0029) ;---------------------------------------------------
                                   (0030) 
                                   (0031) ;------------------------
                                   (0032) ; Includes
                                   (0033) ;------------------------
                                   (0034) 
                                   (0035) 	
                                   (0036) ;------------------------
                                   (0037) ;  Constant Definitions
                                   (0038) ;------------------------
                                   (0039) 
                                   (0040) 
                                   (0041) ;------------------------
                                   (0042) ; Variable Allocation
                                   (0043) ;------------------------
                                   (0044) 
                                   (0045) 
                                   (0046) ;---------------------------------------------------
                                   (0047) ; Insert your custom declarations above this banner
                                   (0048) ;---------------------------------------------------
                                   (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0050) 
                                   (0051) 
                                   (0052) AREA UserModules (ROM, REL)
                                   (0053) 
                                   (0054) ;-----------------------------------------------------------------------------
                                   (0055) ;  FUNCTION NAME: _LED7SEG_1_ISR
                                   (0056) ;
                                   (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                   (0058) ;
                                   (0059) ;-----------------------------------------------------------------------------
                                   (0060) ;
                                   (0061) 
                                   (0062) _LED7SEG_1_ISR:
                                   (0063) 
03B0: 7C 04 29 LCALL 0x0429        (0064)    lcall  LED7SEG_1_Update   ; A and X are preserved for this call.
                                   (0065) 
                                   (0066)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0067)    ;---------------------------------------------------
                                   (0068)    ; Insert your custom code below this banner
                                   (0069)    ;---------------------------------------------------
                                   (0070)    ;   NOTE: interrupt service routines must preserve
                                   (0071)    ;   the values of the A and X CPU registers.
                                   (0072)    ;---------------------------------------------------
                                   (0073) 
                                   (0074) 
                                   (0075)    ;---------------------------------------------------
                                   (0076)    ; Insert your custom code above this banner
                                   (0077)    ;---------------------------------------------------
                                   (0078)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0079) 
03B3: 7E       RETI                (0080)    reti
03B4: 3F 06    MVI   [6],A
03B6: 5B       MOV   A,X
03B7: 4F       MOV   X,SP
03B8: 66 6D    ASL   [X+109]
03BA: 7D 07 7F LJMP  0x077F
03BD: 6F 77    RRC   [X+119]
03BF: 7C 39 5E LCALL 0x395E
03C2: 79       DEC   X
03C3: 71 40    OR    F,64
03C5: 01 02    ADD   A,2
03C7: 04 08    ADD   [8],A
03C9: 10       PUSH  X
03CA: 20       POP   X
03CB: 40       NOP   
03CC: 80 00    JMP   0x03CD
03CE: 01 00    ADD   A,0
03D0: 0A 00    ADC   A,[0]
03D2: 64       ASL   A
03D3: 03 E8    ADD   A,[X-24]
03D5: 27 10 70 AND   [X+16],112

FILE: lib\led7seg_1.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME:   LED7SEG_1.asm
                                   (0004) ;;  Version: 1.0, Updated on 2006/06/14 at 07:47:37
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: Seven Segment LCD user module for 22/24/27/29xxx PSoC family of devices.
                                   (0008) ;;
                                   (0009) ;; This set of functions is written to dirve from 1 to 8 seven segment displays.
                                   (0010) ;;
                                   (0011) ;;  LCD connections to PSoC port
                                   (0012) ;;
                                   (0013) ;;    PX.0 ==> LED a                      a
                                   (0014) ;;    PX.1 ==> LED b                    =====
                                   (0015) ;;    PX.2 ==> LED c                   ||   || b
                                   (0016) ;;    PX.3 ==> LED d                 f || g ||
                                   (0017) ;;    PX.4 ==> LED e                    =====
                                   (0018) ;;    PX.5 ==> LED f                   ||   || c
                                   (0019) ;;    PX.6 ==> LED g                 e ||   ||
                                   (0020) ;;    PX.7 ==> LED dp                   =====  # dp
                                   (0021) ;;                                        d     
                                   (0022) ;;    PY.0 ==> Digit 1
                                   (0023) ;;    PY.1 ==> Digit 2
                                   (0024) ;;    PY.2 ==> Digit 3         Digit Number
                                   (0025) ;;    PY.3 ==> Digit 4        +---+---+---+---+---+---+---+---+
                                   (0026) ;;    PY.4 ==> Digit 5        | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
                                   (0027) ;;    PY.5 ==> Digit 6        +---+---+---+---+---+---+---+---+
                                   (0028) ;;    PY.6 ==> Digit 7
                                   (0029) ;;    PY.7 ==> Digit 8
                                   (0030) ;;
                                   (0031) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0032) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0033) ;;        This means it is the caller's responsibility to preserve any values
                                   (0034) ;;        in the X and A registers that are still needed after the API functions
                                   (0035) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0036) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0037) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0038) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0039) ;;-----------------------------------------------------------------------------
                                   (0040) ;;  Copyright (c) Cypress MicroSystems 2001-2004. All Rights Reserved.
                                   (0041) ;;*****************************************************************************
                                   (0042) ;;*****************************************************************************
                                   (0043) 
                                   (0044) include "LED7SEG_1.inc"
                                   (0045) include "memory.inc"
                                   (0046) 
                                   (0047) export _LED7SEG_1_Start
                                   (0048) export  LED7SEG_1_Start
                                   (0049) 
                                   (0050) export _LED7SEG_1_Stop
                                   (0051) export  LED7SEG_1_Stop
                                   (0052) 
                                   (0053) export _LED7SEG_1_Dim
                                   (0054) export  LED7SEG_1_Dim
                                   (0055) 
                                   (0056) export _LED7SEG_1_Update
                                   (0057) export  LED7SEG_1_Update
                                   (0058) 
                                   (0059) export _LED7SEG_1_PutHex
                                   (0060) export  LED7SEG_1_PutHex
                                   (0061) 
                                   (0062) export _LED7SEG_1_PutPattern
                                   (0063) export  LED7SEG_1_PutPattern
                                   (0064) 
                                   (0065) export _LED7SEG_1_DP
                                   (0066) export  LED7SEG_1_DP
                                   (0067) 
                                   (0068) export _LED7SEG_1_DispInt 
                                   (0069) export  LED7SEG_1_DispInt
                                   (0070) 
                                   (0071) export  LED7SEG_1_DigitRAM
                                   (0072) export _LED7SEG_1_DigitRAM
                                   (0073) 
                                   (0074) export  LED7SEG_1_ScanStatus
                                   (0075) export _LED7SEG_1_ScanStatus
                                   (0076) 
                                   (0077) area InterruptRAM(RAM, REL, CON)
                                   (0078) 
                                   (0079)  LED7SEG_1_VarPage:                              ; Dummy label for paging
                                   (0080) 
                                   (0081)  LED7SEG_1_ScanStatus:
                                   (0082) _LED7SEG_1_ScanStatus:                       blk      1
                                   (0083) 
                                   (0084)  LED7SEG_1_DigitRAM:
                                   (0085) _LED7SEG_1_DigitRAM:                         blk      LED7SEG_1_DigitCnt
                                   (0086) 
                                   (0087) AREA UserModules (ROM, REL)
                                   (0088) 
                                   (0089) ;; 
                                   (0090) ;;  char dp g f e   d c b a    Code  Code
                                   (0091) ;;   0    0 0 1 1   1 1 1 1    0x3F  0xC0
                                   (0092) ;;   1    0 0 0 0   0 1 1 0    0x06  0xF9
                                   (0093) ;;   2    0 1 0 1   1 0 1 1    0x5B  0xA4
                                   (0094) ;;   3    0 1 0 0   1 1 1 1    0x4F  0xB0
                                   (0095) ;;   4    0 1 1 0   0 1 1 0    0x66  0x99
                                   (0096) ;;   5    0 1 1 0   1 1 0 1    0x6D  0x92
                                   (0097) ;;   6    0 1 1 1   1 1 0 1    0x7D  0x82
                                   (0098) ;;   7    0 0 0 0   0 1 1 1    0x07  0xF8
                                   (0099) ;;   8    0 1 1 1   1 1 1 1    0x7F  0x80
                                   (0100) ;;   9    0 1 1 0   1 1 1 1    0x6F  0x90
                                   (0101) ;;   A    0 1 1 1   0 1 1 1    0x77  0x88
                                   (0102) ;;   b    0 1 1 1   1 1 0 0    0x7C  0x83
                                   (0103) ;;   C    0 0 1 1   1 0 0 1    0x39  0xC6
                                   (0104) ;;   d    0 1 0 1   1 1 1 0    0x5E  0xA1
                                   (0105) ;;   E    0 1 1 1   1 0 0 1    0x79  0x86
                                   (0106) ;;   F    0 1 1 1   0 0 0 1    0x71  0x8E
                                   (0107) ;;   -    0 1 0 0   0 0 0 0    0x40  0xBF
                                   (0108) 
                                   (0109) 
                                   (0110) 
                                   (0111) .LITERAL
                                   (0112)  LED7SEG_1_HexSegMask:
                                   (0113) 
                                   (0114)      DB   0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07
                                   (0115)      DB   0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71
                                   (0116)      DB   0x40
                                   (0117) 
                                   (0118) 
                                   (0119)  LED7SEG_1_DigitPortMask:
                                   (0120) IF(LED7SEG_1_DigitDrive)  // Active High Digit Drive
                                   (0121)      DB   LED7SEG_1_Dig1Mask
                                   (0122)      DB   LED7SEG_1_Dig2Mask
                                   (0123)      DB   LED7SEG_1_Dig3Mask
                                   (0124)      DB   LED7SEG_1_Dig4Mask
                                   (0125)      DB   LED7SEG_1_Dig5Mask
                                   (0126)      DB   LED7SEG_1_Dig6Mask
                                   (0127)      DB   LED7SEG_1_Dig7Mask
                                   (0128)      DB   LED7SEG_1_Dig8Mask
                                   (0129) ELSE                             // Active Low Digit Drive
                                   (0130)      DB   ~LED7SEG_1_Dig1Mask
                                   (0131)      DB   ~LED7SEG_1_Dig2Mask
                                   (0132)      DB   ~LED7SEG_1_Dig3Mask
                                   (0133)      DB   ~LED7SEG_1_Dig4Mask
                                   (0134)      DB   ~LED7SEG_1_Dig5Mask
                                   (0135)      DB   ~LED7SEG_1_Dig6Mask
                                   (0136)      DB   ~LED7SEG_1_Dig7Mask
                                   (0137)      DB   ~LED7SEG_1_Dig8Mask
                                   (0138) ENDIF
                                   (0139) 
                                   (0140) 
                                   (0141) DEC_TABLE:   ; Used for base10 display
                                   (0142) DW 0x0001, 0x000A, 0x0064, 0x03E8, 0x2710
                                   (0143) ;    1       10     100     1000   10,000
                                   (0144) 
                                   (0145) .ENDLITERAL
                                   (0146) 
                                   (0147) .SECTION
                                   (0148) ;-----------------------------------------------------------------------------
                                   (0149) ;  FUNCTION NAME: LED7SEG_1_Start(void)
                                   (0150) ;
                                   (0151) ;  DESCRIPTION:
                                   (0152) ;     Init state machine and clear buffer memory
                                   (0153) ;
                                   (0154) ;-----------------------------------------------------------------------------
                                   (0155) ;
                                   (0156) ;  ARGUMENTS:
                                   (0157) ;    none
                                   (0158) ;
                                   (0159) ;  RETURNS:  none
                                   (0160) ;
                                   (0161) ;  SIDE EFFECTS:
                                   (0162) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0163) ;
                                   (0164) ;-----------------------------------------------------------------------------
                                   (0165) _LED7SEG_1_Start:
                                   (0166)  LED7SEG_1_Start:
03D8: BF 62    JNZ   0x033B        (0167)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0168)    RAM_PROLOGUE RAM_USE_CLASS_4
03DA: D3 00    JNC   0x06DB        (0169)    RAM_SETPAGE_IDX >LED7SEG_1_VarPage
03DC: 62 D0 00 MOV   REG[208],0    (0170)    RAM_SETPAGE_CUR >LED7SEG_1_VarPage
03DF: 10       PUSH  X             (0171)    push   X
                                   (0172)    ; Initialize digit RAM
03E0: 57 07    MOV   X,7           (0173)    mov    X,(LED7SEG_1_DigitCnt-1)
                                   (0174) .ClearLoop:
03E2: 56 02 00 MOV   [X+2],0       (0175)    mov    [X+LED7SEG_1_DigitRAM],LED7SEG_1_SegmentInit
03E5: 79       DEC   X             (0176)    dec    X
03E6: DF FB    JNC   0x03E2        (0177)    jnc    .ClearLoop
                                   (0178) 
                                   (0179)    ; Set scan bit
03E8: 55 01 80 MOV   [1],128       (0180)    mov   [LED7SEG_1_ScanStatus],LED7SEG_1_ScanFlag  
                                   (0181) 
                                   (0182) 
03EB: 71 10    OR    F,16          (0183)    M8C_SetBank1
03ED: 43 00 FF OR    REG[0],255    (0184)    or    reg[LED7SEG_1_DigitPortDM0],LED7SEG_1_DigitMask
03F0: 41 01 00 AND   REG[1],0      (0185)    and   reg[LED7SEG_1_DigitPortDM1],~LED7SEG_1_DigitMask
03F3: 70 EF    AND   F,239         (0186)    M8C_SetBank0
03F5: 41 03 00 AND   REG[3],0      (0187)    and   reg[LED7SEG_1_DigitPortDM2],~LED7SEG_1_DigitMask
                                   (0188) 
03F8: 20       POP   X             (0189)    pop   X
                                   (0190) 
                                   (0191) IF (LED7SEG_1_TIMER_PRESENT)
03F9: 43 2B 01 OR    REG[43],1     (0192)    or    reg[LED7SEG_1_CONTROL_REG],  LED7SEG_1_CONTROL_REG_START_BIT
03FC: 43 E1 04 OR    REG[225],4    (0193)    M8C_EnableIntMask LED7SEG_1_INT_REG, LED7SEG_1_INT_MASK
03FF: 70 3F    AND   F,63
                                   (0194) ENDIF
                                   (0195) 
                                   (0196)    RAM_EPILOGUE RAM_USE_CLASS_4
0401: 71 C0    OR    F,192         (0197)    RAM_EPILOGUE RAM_USE_CLASS_3
0403: 7F       RET                 (0198)    ret
                                   (0199) .ENDSECTION
                                   (0200) 
                                   (0201) 
                                   (0202) .SECTION
                                   (0203) ;-----------------------------------------------------------------------------
                                   (0204) ;  FUNCTION NAME: LED7SEG_1_Stop(void)
                                   (0205) ;
                                   (0206) ;  DESCRIPTION:
                                   (0207) ;     Stops scanning and turn off all digits
                                   (0208) ;
                                   (0209) ;-----------------------------------------------------------------------------
                                   (0210) ;
                                   (0211) ;  ARGUMENTS:
                                   (0212) ;    none
                                   (0213) ;
                                   (0214) ;  RETURNS:  none
                                   (0215) ;
                                   (0216) ;  SIDE EFFECTS:
                                   (0217) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0218) ;
                                   (0219) ;-----------------------------------------------------------------------------
                                   (0220) _LED7SEG_1_Stop:
                                   (0221)  LED7SEG_1_Stop:
                                   (0222)    RAM_PROLOGUE RAM_USE_CLASS_4
0404: 62 D0 00 MOV   REG[208],0    (0223)    RAM_SETPAGE_CUR >LED7SEG_1_VarPage
                                   (0224) 
0407: 08       PUSH  A             (0225)    push A
                                   (0226)    ; Turn off scan
0408: 55 01 00 MOV   [1],0         (0227)    mov   [LED7SEG_1_ScanStatus],0x00 
                                   (0228) 
                                   (0229)    ; Turn off all digits
                                   (0230) IF(1)                                            ; Active High Digit Drive
040B: 26 00 00 AND   [0],0         (0231)    and  [Port_0_Data_SHADE],~LED7SEG_1_DigitMask
                                   (0232) ELSE                                             ; Active Low Digit Drive
                                   (0233)    or   [Port_0_Data_SHADE],LED7SEG_1_DigitMask
                                   (0234) ENDIF
040E: 51 00    MOV   A,[0]         (0235)    mov  A,[Port_0_Data_SHADE]    
0410: 60 00    MOV   REG[0],A      (0236)    mov  reg[LED7SEG_1_DigitPortDR],A
0412: 18       POP   A             (0237)    pop  A
                                   (0238) 
                                   (0239) IF (LED7SEG_1_TIMER_PRESENT)
0413: 41 E1 FB AND   REG[225],251  (0240)    M8C_DisableIntMask LED7SEG_1_INT_REG, LED7SEG_1_INT_MASK
0416: 41 2B FE AND   REG[43],254   (0241)    and   reg[LED7SEG_1_CONTROL_REG], ~LED7SEG_1_CONTROL_REG_START_BIT
                                   (0242) ENDIF
                                   (0243) 
                                   (0244)    RAM_EPILOGUE RAM_USE_CLASS_4
0419: 7F       RET                 (0245)    ret
                                   (0246) .ENDSECTION
                                   (0247) 
                                   (0248) 
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: LED7SEG_1_Dim(Byte bDim)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Init state machine and clear buffer memory
                                   (0256) ;
                                   (0257) ;-----------------------------------------------------------------------------
                                   (0258) ;
                                   (0259) ;  ARGUMENTS:
                                   (0260) ;    A => bDim   ( Dim Off = 0,  Dim On = 1)
                                   (0261) ;
                                   (0262) ;  RETURNS:  none
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0266) ;
                                   (0267) ;-----------------------------------------------------------------------------
                                   (0268) _LED7SEG_1_Dim:
                                   (0269)  LED7SEG_1_Dim:
                                   (0270)   
                                   (0271)    RAM_PROLOGUE RAM_USE_CLASS_4
041A: 62 D0 00 MOV   REG[208],0    (0272)    RAM_SETPAGE_CUR >LED7SEG_1_VarPage
                                   (0273) 
041D: 21 01    AND   A,1           (0274)    and    A,0x01
041F: A0 05    JZ    0x0425        (0275)    jz     .DimOff
                                   (0276) 
                                   (0277) .DimOn:
0421: 2E 01 40 OR    [1],64        (0278)    or     [LED7SEG_1_ScanStatus],LED7SEG_1_DimEnable
                                   (0279)    RAM_EPILOGUE RAM_USE_CLASS_4
0424: 7F       RET                 (0280)    ret
                                   (0281) 
                                   (0282) .DimOff:
0425: 26 01 BF AND   [1],191       (0283)    and    [LED7SEG_1_ScanStatus],~LED7SEG_1_DimEnable
                                   (0284)    RAM_EPILOGUE RAM_USE_CLASS_4
0428: 7F       RET                 (0285)    ret
                                   (0286) 
                                   (0287) .ENDSECTION
                                   (0288) 
                                   (0289) .SECTION
                                   (0290) ;-----------------------------------------------------------------------------
                                   (0291) ;  FUNCTION NAME: LED7SEG_1_Update(void)
                                   (0292) ;
                                   (0293) ;  DESCRIPTION:
                                   (0294) ;     Advance and display next digit from array.  This function is designed
                                   (0295) ;     to be called from an ISR, although it could be called in the mainline
                                   (0296) ;     of your program.
                                   (0297) ;
                                   (0298) ;     To call this function from a non Large Memory Model (LMM) device,
                                   (0299) ;     in an ISR use the following.
                                   (0300) ;
                                   (0301) ;     lcall LED7SEG_1_Update
                                   (0302) ;
                                   (0303) ;     If using a LMM part, and calling from an ISR, make sure the processor
                                   (0304) ;     is either in page mode 0, or in native page mode.  
                                   (0305) ;
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;
                                   (0308) ;  ARGUMENTS:
                                   (0309) ;    none
                                   (0310) ;
                                   (0311) ;  RETURNS:  none
                                   (0312) ;
                                   (0313) ;  SIDE EFFECTS:
                                   (0314) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0315) ;
                                   (0316) ;  How It Works:
                                   (0317) ;    *  Check if Scan is on
                                   (0318) ;    *  Blank display, Turn off common drive
                                   (0319) ;    *  Load Segment register
                                   (0320) ;    *  Set proper digit, (Turn on common drive)
                                   (0321) ;    *  Adance counter to next digit
                                   (0322) ;-----------------------------------------------------------------------------
                                   (0323) _LED7SEG_1_Update:
                                   (0324)  LED7SEG_1_Update:
                                   (0325)    RAM_PROLOGUE RAM_USE_CLASS_4
0429: 70 BF    AND   F,191         (0326)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0327) 
042B: 08       PUSH  A             (0328)    push  A
042C: 10       PUSH  X             (0329)    push  X
042D: 5D D3    MOV   A,REG[211]
                                   (0330)    IF (SYSTEM_LARGE_MEMORY_MODEL)
042F: 08       PUSH  A             (0331)       REG_PRESERVE IDX_PP
0430: 5D D0    MOV   A,REG[208]
0432: 08       PUSH  A             (0332)       REG_PRESERVE CUR_PP
                                   (0333)    ENDIF
                                   (0334) 
0433: 62 D3 00 MOV   REG[211],0    (0335)    RAM_SETPAGE_IDX >LED7SEG_1_VarPage
0436: 62 D0 00 MOV   REG[208],0    (0336)    RAM_SETPAGE_CUR >LED7SEG_1_VarPage
                                   (0337) 
0439: 47 01 80 TST   [1],128       (0338)    tst   [LED7SEG_1_ScanStatus],LED7SEG_1_ScanFlag  // Test if scanning is enabled
043C: A0 3B    JZ    0x0478        (0339)    jz    .Update_End
                                   (0340) 
                                   (0341)    ; Turn off display briefly
                                   (0342) IF(1)                                            ; Active High Digit Drive
043E: 26 00 00 AND   [0],0         (0343)    and  [Port_0_Data_SHADE],~LED7SEG_1_DigitMask
                                   (0344) ELSE                                             ; Active Low Digit Drive
                                   (0345)    or   [Port_0_Data_SHADE],LED7SEG_1_DigitMask
                                   (0346) ENDIF
0441: 51 00    MOV   A,[0]         (0347)    mov   A,[Port_0_Data_SHADE]    
0443: 60 00    MOV   REG[0],A      (0348)    mov   reg[LED7SEG_1_DigitPortDR],A
                                   (0349) 
                                   (0350)    ; Get the segment value, and write it to the segment port
0445: 51 01    MOV   A,[1]         (0351)    mov   A,[LED7SEG_1_ScanStatus]
0447: 21 0F    AND   A,15          (0352)    and   A,LED7SEG_1_CntMask                     ; Mask off all but scan position
0449: 4B       SWAP  A,X           (0353)    swap  A,X
                                   (0354) 
                                   (0355)    ; Check for Dim flag
044A: 47 01 20 TST   [1],32        (0356)    tst   [LED7SEG_1_ScanStatus],LED7SEG_1_DimFlag   ; If set skip update
044D: B0 0E    JNZ   0x045C        (0357)    jnz   .IncDigit
                                   (0358) 
044F: 52 02    MOV   A,[X+2]       (0359)    mov   A,[X+LED7SEG_1_DigitRAM]
                                   (0360) 
                                   (0361) ; Invert here if Active Low segment drive
                                   (0362) IF(1)                                            ; Active Low Segment Drive
                                   (0363)    ; Do nothing
                                   (0364) ELSE
                                   (0365)    cpl   A
                                   (0366) ENDIF
0451: 60 14    MOV   REG[20],A     (0367)    mov   reg[LED7SEG_1_SegmentPortDR],A
                                   (0368) 
                                   (0369)    ; Turn digit back on
                                   (0370) 
0453: 5B       MOV   A,X           (0371)    mov   A,X                                     ; Copy index into A
0454: FF 6F    INDEX 0x03C5        (0372)    index LED7SEG_1_DigitPortMask                 ; Digit mask into A
                                   (0373) 
                                   (0374) IF(1)                                            ; Active High Digit Drive
0456: 2C 00    OR    [0],A         (0375)    or   [Port_0_Data_SHADE],A
                                   (0376) ELSE                                             ; Active Low Digit Drive
                                   (0377)    and  [Port_0_Data_SHADE],A
                                   (0378) ENDIF
0458: 51 00    MOV   A,[0]         (0379)    mov  A,[Port_0_Data_SHADE]
045A: 60 00    MOV   REG[0],A      (0380)    mov  reg[LED7SEG_1_DigitPortDR],A
                                   (0381) 
                                   (0382) 
                                   (0383)    ; Calculate next digit
                                   (0384) .IncDigit:
045C: 4B       SWAP  A,X           (0385)    swap  A,X                                     ; Put current digit into A
045D: 74       INC   A             (0386)    inc   A                                       ; Advance to next
045E: 76 01    INC   [1]           (0387)    inc   [LED7SEG_1_ScanStatus]
0460: 11 08    SUB   A,8           (0388)    sub   A,LED7SEG_1_DigitCnt
0462: A0 05    JZ    0x0468        (0389)    jz    .Reset_Count
0464: D0 03    JNC   0x0468        (0390)    jnc   .Reset_Count
0466: 80 11    JMP   0x0478        (0391)    jmp   .Update_End
                                   (0392) 
                                   (0393) .Reset_Count:
0468: 26 01 F0 AND   [1],240       (0394)    and   [LED7SEG_1_ScanStatus],~LED7SEG_1_CntMask    ; Reset count to zero  
046B: 47 01 40 TST   [1],64        (0395)    tst   [LED7SEG_1_ScanStatus],LED7SEG_1_DimEnable   ; If set skip update
046E: A0 06    JZ    0x0475        (0396)    jz    .Update_End_DimOff
0470: 36 01 20 XOR   [1],32        (0397)    xor   [LED7SEG_1_ScanStatus],LED7SEG_1_DimFlag   
0473: 80 04    JMP   0x0478        (0398)    jmp   .Update_End
                                   (0399) 
                                   (0400) .Update_End_DimOff:                              ; Make sure Dim is off
0475: 26 01 DF AND   [1],223       (0401)    and   [LED7SEG_1_ScanStatus],~LED7SEG_1_DimFlag    ; Make sure dim flag off
0478: 18       POP   A
                                   (0402) 
                                   (0403) .Update_End:
                                   (0404)    IF (SYSTEM_LARGE_MEMORY_MODEL)  
0479: 60 D0    MOV   REG[208],A    (0405)       REG_RESTORE CUR_PP
047B: 18       POP   A
047C: 60 D3    MOV   REG[211],A    (0406)       REG_RESTORE IDX_PP
                                   (0407)    ENDIF
                                   (0408) 
047E: 20       POP   X             (0409)    pop   X
047F: 18       POP   A             (0410)    pop   A
0480: 70 3F    AND   F,63
                                   (0411) .Update_Exit:
                                   (0412) 
0482: 71 C0    OR    F,192         (0413)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0414)    RAM_EPILOGUE RAM_USE_CLASS_4
0484: 7F       RET                 (0415)    ret
                                   (0416) .ENDSECTION
                                   (0417) 
                                   (0418) .SECTION
                                   (0419) ;-----------------------------------------------------------------------------
                                   (0420) ;  FUNCTION NAME: LED7SEG_1_PutHex(BYTE bValue, BYTE bDigit)
                                   (0421) ;
                                   (0422) ;  DESCRIPTION:
                                   (0423) ;     Write hex value to one of the digits
                                   (0424) ;
                                   (0425) ;-----------------------------------------------------------------------------
                                   (0426) ;
                                   (0427) ;  ARGUMENTS:
                                   (0428) ;    A => Value to display
                                   (0429) ;    X => Digit to update  ( 1 to n )
                                   (0430) ;
                                   (0431) ;  RETURNS:  none
                                   (0432) ;
                                   (0433) ;  SIDE EFFECTS:
                                   (0434) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0435) ;
                                   (0436) ;-----------------------------------------------------------------------------
                                   (0437) _LED7SEG_1_PutHex:
                                   (0438)  LED7SEG_1_PutHex:
0485: 70 BF    AND   F,191         (0439)    RAM_PROLOGUE RAM_USE_CLASS_3  
0487: 62 D3 00 MOV   REG[211],0    (0440)    RAM_SETPAGE_IDX >LED7SEG_1_VarPage
                                   (0441)   
048A: FF 28    INDEX 0x03B4        (0442)    index   LED7SEG_1_HexSegMask                  ; Get code
048C: 79       DEC   X             (0443)    dec     X                                     ; Dec to shift from (1 to N) to (0 to N-1)
048D: 4B       SWAP  A,X           (0444)    swap    A,X                                   ; Code in X, index in A
048E: 39 08    CMP   A,8           (0445)    cmp     A,(LED7SEG_1_DigitCnt)
0490: D0 07    JNC   0x0498        (0446)    jnc     .putHex_End
                                   (0447) 
0492: 4B       SWAP  A,X           (0448)    swap    A,X                                   ; Code in A, index in X
0493: 27 02 80 AND   [X+2],128     (0449)    and     [X+LED7SEG_1_DigitRAM],0x80
0496: 2D 02    OR    [X+2],A       (0450)    or      [X+LED7SEG_1_DigitRAM],A
0498: 70 3F    AND   F,63
                                   (0451) .putHex_End:
049A: 71 C0    OR    F,192         (0452)    RAM_EPILOGUE RAM_USE_CLASS_3
049C: 7F       RET                 (0453)    ret
                                   (0454) .ENDSECTION
                                   (0455) 
                                   (0456) .SECTION
                                   (0457) ;-----------------------------------------------------------------------------
                                   (0458) ;  FUNCTION NAME: LED7SEG_1_PutPattern(BYTE bPattern, BYTE bDigit)
                                   (0459) ;
                                   (0460) ;  DESCRIPTION:
                                   (0461) ;     Write pattern to 7 segment display
                                   (0462) ;
                                   (0463) ;-----------------------------------------------------------------------------
                                   (0464) ;
                                   (0465) ;  ARGUMENTS:
                                   (0466) ;    A => Pattern to display
                                   (0467) ;    X => Digit to update  ( 1 to n )
                                   (0468) ;
                                   (0469) ;  RETURNS:  none
                                   (0470) ;
                                   (0471) ;  SIDE EFFECTS:
                                   (0472) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0473) ;
                                   (0474) ;-----------------------------------------------------------------------------
                                   (0475) _LED7SEG_1_PutPattern:
                                   (0476)  LED7SEG_1_PutPattern:
049D: 70 BF    AND   F,191         (0477)    RAM_PROLOGUE RAM_USE_CLASS_3  
049F: 62 D3 00 MOV   REG[211],0    (0478)    RAM_SETPAGE_IDX >LED7SEG_1_VarPage
                                   (0479)   
04A2: 79       DEC   X             (0480)    dec     X                                     ; Dec to shift from (1 to N) to (0 to N-1)
04A3: 4B       SWAP  A,X           (0481)    swap    A,X                                   ; Code in X, index in A
04A4: 39 08    CMP   A,8           (0482)    cmp     A,(LED7SEG_1_DigitCnt)
04A6: D0 04    JNC   0x04AB        (0483)    jnc     .putPat_End
                                   (0484) 
04A8: 4B       SWAP  A,X           (0485)    swap    A,X                                   ; Code in A, index in X
04A9: 54 02    MOV   [X+2],A       (0486)    mov     [X+LED7SEG_1_DigitRAM],A
04AB: 70 3F    AND   F,63
                                   (0487) .putPat_End:
04AD: 71 C0    OR    F,192         (0488)    RAM_EPILOGUE RAM_USE_CLASS_3
04AF: 7F       RET                 (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: LED7SEG_1_DP(BYTE bDpOnOff, BYTE bDigit)
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Set the decimal point with the given mask.
                                   (0498) ;
                                   (0499) ;-----------------------------------------------------------------------------
                                   (0500) ;
                                   (0501) ;  ARGUMENTS:
                                   (0502) ;    A => DP ON/OFF (0 = DP Off, 1 = DP On)
                                   (0503) ;    X => Digit  (1 to N)
                                   (0504) ;
                                   (0505) ;  RETURNS:  none
                                   (0506) ;
                                   (0507) ;  SIDE EFFECTS:
                                   (0508) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0509) ;
                                   (0510) ;-----------------------------------------------------------------------------
                                   (0511) _LED7SEG_1_DP:
                                   (0512)  LED7SEG_1_DP:
04B0: 70 BF    AND   F,191         (0513)    RAM_PROLOGUE RAM_USE_CLASS_3  
04B2: 62 D3 00 MOV   REG[211],0    (0514)    RAM_SETPAGE_IDX >LED7SEG_1_VarPage
04B5: 79       DEC   X             (0515)    dec    X                                      ; noramlize from 1 - N, to 0 to N-1
04B6: 4B       SWAP  A,X           (0516)    swap   A,X
04B7: 39 08    CMP   A,8           (0517)    cmp    A,(LED7SEG_1_DigitCnt)
04B9: D0 0E    JNC   0x04C8        (0518)    jnc    .DP_End
                                   (0519)    
04BB: 4B       SWAP  A,X           (0520)    swap   A,X
04BC: 39 00    CMP   A,0           (0521)    cmp    A,0x00                                 ; Is flag set
04BE: A0 06    JZ    0x04C5        (0522)    jz     .DPOff
                                   (0523) 
04C0: 2F 02 80 OR    [X+2],128     (0524)    or     [X+LED7SEG_1_DigitRAM],0x80            ; Set DP
04C3: 80 04    JMP   0x04C8        (0525)    jmp    .DP_End
                                   (0526) .DPOff:
04C5: 27 02 7F AND   [X+2],127     (0527)    and    [X+LED7SEG_1_DigitRAM],0x7F            ; Clear DP
04C8: 70 3F    AND   F,63
                                   (0528) 
                                   (0529) .DP_End:
04CA: 71 C0    OR    F,192         (0530)    RAM_EPILOGUE RAM_USE_CLASS_3
04CC: 7F       RET                 (0531)    ret
04CD: 70 3F    AND   F,63
                                   (0532) .ENDSECTION
                                   (0533) 
                                   (0534) 
                                   (0535) .SECTION
                                   (0536) ;-----------------------------------------------------------------------------
                                   (0537) ;  FUNCTION NAME: LED7SEG_1_DispInt(int iValue, BYTE bPos, BYTE bLSD)
                                   (0538) ;
                                   (0539) ;  DESCRIPTION:
                                   (0540) ;     Display integer on 7-Segment display
                                   (0541) ;
                                   (0542) ;-----------------------------------------------------------------------------
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;          [SP-3] => iValue[7:0]   Value to convert
                                   (0546) ;          [SP-4] => iValue[15:8]  
                                   (0547) ;          [SP-5] => bPos[7:0]     Digit starting position
                                   (0548) ;          [SP-6] => bLSD[7:0]     Digits to display
                                   (0549) ;
                                   (0550) ;
                                   (0551) ;  RETURNS:  none
                                   (0552) ;
                                   (0553) ;  SIDE EFFECTS:
                                   (0554) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0555) ;
                                   (0556) ;-----------------------------------------------------------------------------
                                   (0557) ;
                                   (0558) DI_ValueLSB:   equ   -3
                                   (0559) DI_ValueMSB:   equ   -4
                                   (0560) DI_POS:        equ   -5
                                   (0561) DI_LSD:        equ   -6
                                   (0562) DI_DECPTR:     equ    0
                                   (0563) DI_RESULT:     equ    1
                                   (0564) DI_TMP:        equ    2
                                   (0565) DI_STACKSIZE:  equ    3
                                   (0566) 
                                   (0567) _LED7SEG_1_DispInt:
                                   (0568)  LED7SEG_1_DispInt:
04CF: 71 C0    OR    F,192         (0569)    RAM_EPILOGUE RAM_USE_CLASS_2
                                   (0570)    
04D1: 4F       MOV   X,SP          (0571)    mov   X,SP                                    ; Get copy of the stack pointer
04D2: 38 03    ADD   SP,3          (0572)    add   SP,DI_STACKSIZE                         ; Make some extra room for vars
                                   (0573) 
                                   (0574)    ; Testing only
04D4: 52 FC    MOV   A,[X-4]       (0575)    mov   A,[X+DI_ValueMSB]
04D6: 52 FD    MOV   A,[X-3]       (0576)    mov   A,[X+DI_ValueLSB]
04D8: 52 FB    MOV   A,[X-5]       (0577)    mov   A,[X+DI_POS]
04DA: 7B FA    DEC   [X-6]         (0578)    dec   [X+DI_LSD]                              ; shift count from [1 to N] to [0 to N-1]
                                   (0579) 
04DC: 56 00 04 MOV   [X+0],4       (0580)    mov   [X+DI_DECPTR],4                         ; Load dec ptr with 10000 value
                                   (0581) 
                                   (0582) 
                                   (0583)    ; Comapare input value to decade
                                   (0584) .DEC_LOOP_TOP:
04DF: 56 01 00 MOV   [X+1],0       (0585)    mov   [X+DI_RESULT],0                         ; Reset result
                                   (0586) .DEC_LOOP:
                                   (0587)    ; Compare MSB
04E2: 52 00    MOV   A,[X+0]       (0588)    mov   A,[X+DI_DECPTR]
04E4: 64       ASL   A             (0589)    asl   A                                       ; Index it for 2 (word) bytes ber value
04E5: FE E6    INDEX 0x03CD        (0590)    index DEC_TABLE
04E7: 3B FC    CMP   A,[X-4]       (0591)    cmp   A,[X+DI_ValueMSB]                       ; Is 10^x > Value  (10^x - value)
04E9: C0 0F    JC    0x04F9        (0592)    jc    .DO_INC_SUB                             ; If value is still bigger, increment and subtract
04EB: B0 24    JNZ   0x0510        (0593)    jnz   .TRY_NEXT_DEC
                                   (0594) 
                                   (0595)    ; Compare LSB only if MSB values were equal
04ED: 52 00    MOV   A,[X+0]       (0596)    mov   A,[X+DI_DECPTR]                         ; Get LSB of DEC value
04EF: 64       ASL   A             (0597)    asl   A                                       ; Index it for 2 bytes per value
04F0: 74       INC   A             (0598)    inc   A                                       ; Advance to LSB value
04F1: FE DA    INDEX 0x03CD        (0599)    index DEC_TABLE
04F3: 3B FD    CMP   A,[X-3]       (0600)    cmp   A,[X+DI_ValueLSB]                       ; Is 10^x > Value  (10^x - value)
04F5: C0 03    JC    0x04F9        (0601)    jc    .DO_INC_SUB                             ; If value is still bigger, increment and subtract
04F7: B0 18    JNZ   0x0510        (0602)    jnz   .TRY_NEXT_DEC
                                   (0603)                                                  ; If it fell through, they are equal
                                   (0604) .DO_INC_SUB:
04F9: 77 01    INC   [X+1]         (0605)    inc   [X+DI_RESULT]                           ; Increment the result counter
                                   (0606)    ; Subtract DEC value from Value
04FB: 52 00    MOV   A,[X+0]       (0607)    mov   A,[X+DI_DECPTR]
04FD: 64       ASL   A             (0608)    asl   A                                       ; Index it for 2 bytes per value
04FE: FE CD    INDEX 0x03CD        (0609)    index DEC_TABLE
0500: 54 02    MOV   [X+2],A       (0610)    mov   [X+DI_TMP],A                            ; Store this value for a moment  
                                   (0611) 
0502: 52 00    MOV   A,[X+0]       (0612)    mov   A,[X+DI_DECPTR]                         ; Get LSB of DEC value
0504: 64       ASL   A             (0613)    asl   A                                       ; Index it for 2 bytes per value
0505: 74       INC   A             (0614)    inc   A                                       ; Advance to LSB value
0506: FE C5    INDEX 0x03CD        (0615)    index DEC_TABLE
0508: 15 FD    SUB   [X-3],A       (0616)    sub   [X+DI_ValueLSB],A                       ; Is 10^x > Value  (10^x - value)
050A: 52 02    MOV   A,[X+2]       (0617)    mov   A,[X+DI_TMP]
050C: 1D FC    SBB   [X-4],A       (0618)    sbb   [X+DI_ValueMSB],A
050E: 8F D3    JMP   0x04E2        (0619)    jmp   .DEC_LOOP                               ; Keep subtracting until less than.
                                   (0620)    
                                   (0621) .TRY_NEXT_DEC:                                   ; Completed last decade
                                   (0622) 
0510: 52 FA    MOV   A,[X-6]       (0623)    mov   A,[X+DI_LSD]                            ; Get first position
0512: 3B 00    CMP   A,[X+0]       (0624)    cmp   A,[X+DI_DECPTR]      
0514: C0 11    JC    0x0526        (0625)    jc    .SkipPrint                              ; Not ready skip the print
                                   (0626) 
                                   (0627) 
                                   (0628)    ; Figure if digit should be displayed
0516: 52 01    MOV   A,[X+1]       (0629)    mov   A,[X+DI_RESULT]                         ; Get result
0518: 10       PUSH  X             (0630)    push  X
0519: 59 FB    MOV   X,[X-5]       (0631)    mov   X,[X+DI_POS]                            ; Load Position
                                   (0632) 
051B: 71 C0    OR    F,192         (0633)    RAM_SET_NATIVE_PAGING
051D: 9F 66    CALL  0x0485        (0634)    call  LED7SEG_1_PutHex
051F: 70 3F    AND   F,63
0521: 71 C0    OR    F,192         (0635)    RAM_EPILOGUE RAM_USE_CLASS_2                  ; Restore system to class 2 memory mode
0523: 20       POP   X             (0636)    pop   X
0524: 77 FB    INC   [X-5]         (0637)    inc   [X+DI_POS]                              ; Next time print to the right
                                   (0638) 
                                   (0639) .SkipPrint:
0526: 56 01 00 MOV   [X+1],0       (0640)    mov   [X+DI_RESULT],0
0529: 7B 00    DEC   [X+0]         (0641)    dec   [X+DI_DECPTR]
052B: BF B6    JNZ   0x04E2        (0642)    jnz   .DEC_LOOP
                                   (0643) 
052D: 52 FD    MOV   A,[X-3]       (0644)    mov   A,[X+DI_ValueLSB]                       ; Is 10^x > Value  (10^x - value)
052F: 59 FB    MOV   X,[X-5]       (0645)    mov   X,[X+DI_POS]                            ; Load Position
                                   (0646) 
0531: 71 C0    OR    F,192         (0647)    RAM_SET_NATIVE_PAGING
0533: 9F 50    CALL  0x0485        (0648)    call  LED7SEG_1_PutHex
0535: 70 3F    AND   F,63
0537: 71 C0    OR    F,192         (0649)    RAM_EPILOGUE RAM_USE_CLASS_2                  ; Restore system to class 2 memory mode
                                   (0650) 
                                   (0651) .DispInt_End:
0539: 38 FD    ADD   SP,253        (0652)    add   SP,-DI_STACKSIZE                        ; Restore stack
053B: 70 3F    AND   F,63
053D: 71 C0    OR    F,192         (0653)    RAM_EPILOGUE RAM_USE_CLASS_2
053F: 7F       RET                 (0654)    ret

FILE: lib\i2chw_1rsrcinits.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: I2CHW_1.asm
                                   (0004) ;;   Version: 1.5, Updated on 2006/06/06 at 13:39:08
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: I2Cs User Module software implementation file
                                   (0008) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress MicroSystems 2002-2006. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "memory.inc"
                                   (0025) include "I2CHW_1Common.inc"
                                   (0026) 
                                   (0027) ;-----------------------------------------------
                                   (0028) ; include instance specific register definitions
                                   (0029) ;-----------------------------------------------
                                   (0030) 
                                   (0031) ;-----------------------------------------------
                                   (0032) ;  Global Symbols
                                   (0033) ;-----------------------------------------------
                                   (0034) ;-------------------------------------------------------------------
                                   (0035) ;  Declare the functions global for both assembler and C compiler.
                                   (0036) ;
                                   (0037) ;  Note that there are two names for each API. First name is
                                   (0038) ;  assembler reference. Name with underscore is name refence for
                                   (0039) ;  C compiler.  Calling function in C source code does not require
                                   (0040) ;  the underscore.
                                   (0041) ;-------------------------------------------------------------------
                                   (0042) 
                                   (0043) export    I2CHW_1_EnableInt
                                   (0044) export   _I2CHW_1_EnableInt
                                   (0045) export    I2CHW_1_EnableSlave
                                   (0046) export   _I2CHW_1_EnableSlave
                                   (0047) export    I2CHW_1_EnableMstr
                                   (0048) export   _I2CHW_1_EnableMstr
                                   (0049) export    I2CHW_1_Start
                                   (0050) export   _I2CHW_1_Start
                                   (0051) export    I2CHW_1_DisableInt
                                   (0052) export   _I2CHW_1_DisableInt
                                   (0053) export    I2CHW_1_DisableSlave
                                   (0054) export   _I2CHW_1_DisableSlave
                                   (0055) export    I2CHW_1_DisableMstr
                                   (0056) export   _I2CHW_1_DisableMstr
                                   (0057) export    I2CHW_1_Stop
                                   (0058) export   _I2CHW_1_Stop
                                   (0059) 
                                   (0060) 
                                   (0061) AREA UserModules (ROM, REL)
                                   (0062) 
                                   (0063) .SECTION
                                   (0064) 
                                   (0065) ;-----------------------------------------------------------------------------
                                   (0066) ;  FUNCTION NAME: I2CHW_1_Start
                                   (0067) ;
                                   (0068) ;  DESCRIPTION:
                                   (0069) ;   Initialize the I2CHW_1 I2C bus interface.
                                   (0070) ;
                                   (0071) ;-----------------------------------------------------------------------------
                                   (0072) ;
                                   (0073) ;  ARGUMENTS:
                                   (0074) ;
                                   (0075) ;  RETURNS: none
                                   (0076) ;
                                   (0077) ;  SIDE EFFECTS:
                                   (0078) ;    The A and X registers may be modified by this or future implementations
                                   (0079) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0080) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0081) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0082) ;    functions.
                                   (0083) ;          
                                   (0084)  I2CHW_1_Start:
                                   (0085) _I2CHW_1_Start:
                                   (0086)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0087)     RAM_EPILOGUE RAM_USE_CLASS_1
0540: 7F       RET                 (0088)     ret
                                   (0089) .ENDSECTION
                                   (0090) 
                                   (0091) .SECTION
                                   (0092) ;-----------------------------------------------------------------------------
                                   (0093) ;  FUNCTION NAME: I2CHW_1_EnableInt
                                   (0094) ;
                                   (0095) ;  DESCRIPTION:
                                   (0096) ;     Enables SDA interrupt allowing start condition detection. Remember to call the
                                   (0097) ;     global interrupt enable function by using the macro: M8C_EnableGInt.
                                   (0098) ;
                                   (0099) ;-----------------------------------------------------------------------------
                                   (0100) ;
                                   (0101) ;  ARGUMENTS: none
                                   (0102) ;
                                   (0103) ;  RETURNS: none
                                   (0104) ;
                                   (0105) ;  SIDE EFFECTS:
                                   (0106) ;    The A and X registers may be modified by this or future implementations
                                   (0107) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0108) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0109) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0110) ;    functions.
                                   (0111) ;          
                                   (0112)  I2CHW_1_EnableInt:
                                   (0113) _I2CHW_1_EnableInt:
                                   (0114)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0115)     ;first clear any pending interrupts
0541: 08       PUSH  A             (0116)     push A
0542: 5D DD    MOV   A,REG[221]    (0117)     mov A, reg[INT_CLR3]
0544: 21 FE    AND   A,254         (0118)     and A, ~I2CHW_1_INT_MASK
0546: 60 DD    MOV   REG[221],A    (0119)     mov reg[INT_CLR3], A
0548: 43 DE 01 OR    REG[222],1    (0120)     M8C_EnableIntMask I2CHW_1_INT_REG, I2CHW_1_INT_MASK
054B: 18       POP   A             (0121)     pop A
                                   (0122)     RAM_EPILOGUE RAM_USE_CLASS_1
054C: 7F       RET                 (0123)     ret
                                   (0124) 
                                   (0125) .ENDSECTION
                                   (0126) 
                                   (0127) .SECTION
                                   (0128) ;-----------------------------------------------------------------------------
                                   (0129) ;  FUNCTION NAME: I2CHW_1_EnableMstr
                                   (0130) ;
                                   (0131) ;  DESCRIPTION:
                                   (0132) ;     Enables SDA interrupt allowing start condition detection. Remember to call the
                                   (0133) ;     global interrupt enable function by using the macro: M8C_EnableGInt.
                                   (0134) ;
                                   (0135) ;-----------------------------------------------------------------------------
                                   (0136) ;
                                   (0137) ;  ARGUMENTS: none
                                   (0138) ;
                                   (0139) ;  RETURNS: none
                                   (0140) ;
                                   (0141) ;  SIDE EFFECTS:
                                   (0142) ;    The A and X registers may be modified by this or future implementations
                                   (0143) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0144) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0145) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0146) ;    functions.
                                   (0147) ;          
                                   (0148)  I2CHW_1_EnableMstr:
                                   (0149) _I2CHW_1_EnableMstr:
                                   (0150)     RAM_PROLOGUE RAM_USE_CLASS_1
054D: 43 D6 02 OR    REG[214],2    (0151)     BitSetI2CHW_1_CFG I2C_M_EN                                       ;Enable SDA interupt
                                   (0152)     RAM_EPILOGUE RAM_USE_CLASS_1
0550: 7F       RET                 (0153)     ret
                                   (0154) 
                                   (0155) .ENDSECTION
                                   (0156) 
                                   (0157) .SECTION
                                   (0158) ;-----------------------------------------------------------------------------
                                   (0159) ;  FUNCTION NAME: I2CHW_1_EnableSlave
                                   (0160) ;
                                   (0161) ;  DESCRIPTION:
                                   (0162) ;     Enables SDA interrupt allowing start condition detection. Remember to call the
                                   (0163) ;     global interrupt enable function by using the macro: M8C_EnableGInt.
                                   (0164) ;
                                   (0165) ;-----------------------------------------------------------------------------
                                   (0166) ;
                                   (0167) ;  ARGUMENTS: none
                                   (0168) ;
                                   (0169) ;  RETURNS: none
                                   (0170) ;
                                   (0171) ;  SIDE EFFECTS:
                                   (0172) ;    The A and X registers may be modified by this or future implementations
                                   (0173) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0174) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0175) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0176) ;    functions.
                                   (0177) ;          
                                   (0178)  I2CHW_1_EnableSlave:
                                   (0179) _I2CHW_1_EnableSlave:
                                   (0180)     RAM_PROLOGUE RAM_USE_CLASS_1
0551: 43 D6 01 OR    REG[214],1    (0181)     BitSetI2CHW_1_CFG I2C_S_EN                                       ;Enable SDA interupt
                                   (0182)     RAM_EPILOGUE RAM_USE_CLASS_1
0554: 7F       RET                 (0183)     ret
                                   (0184) 
                                   (0185) .ENDSECTION
                                   (0186) 
                                   (0187) .SECTION
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;  FUNCTION NAME: I2CHW_1_DisableInt
                                   (0190) ;  FUNCTION NAME: I2CHW_1_Stop
                                   (0191) ;
                                   (0192) ;  DESCRIPTION:
                                   (0193) ;     Disables I2CHW_1 slave by disabling SDA interrupt
                                   (0194) ;
                                   (0195) ;-----------------------------------------------------------------------------
                                   (0196) ;
                                   (0197) ;  ARGUMENTS: none
                                   (0198) ;
                                   (0199) ;  RETURNS: none
                                   (0200) ;
                                   (0201) ;  SIDE EFFECTS:
                                   (0202) ;    The A and X registers may be modified by this or future implementations
                                   (0203) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0204) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0205) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0206) ;    functions.
                                   (0207) ;          
                                   (0208)  I2CHW_1_DisableInt:
                                   (0209) _I2CHW_1_DisableInt:
                                   (0210)  I2CHW_1_Stop:
                                   (0211) _I2CHW_1_Stop:
                                   (0212)     RAM_PROLOGUE RAM_USE_CLASS_1
0555: 41 DE FE AND   REG[222],254  (0213)     M8C_DisableIntMask I2CHW_1_INT_REG, I2CHW_1_INT_MASK
                                   (0214)     RAM_EPILOGUE RAM_USE_CLASS_1
0558: 7F       RET                 (0215)     ret
                                   (0216) 
                                   (0217) .ENDSECTION
                                   (0218) 
                                   (0219) .SECTION
                                   (0220) ;-----------------------------------------------------------------------------
                                   (0221) ;  FUNCTION NAME: I2CHW_1_DisableSlave
                                   (0222) ;
                                   (0223) ;  DESCRIPTION:
                                   (0224) ;     Disables I2CHW_1 slave by disabling SDA interrupt
                                   (0225) ;
                                   (0226) ;-----------------------------------------------------------------------------
                                   (0227) ;
                                   (0228) ;  ARGUMENTS: none
                                   (0229) ;
                                   (0230) ;  RETURNS: none
                                   (0231) ;
                                   (0232) ;  SIDE EFFECTS:
                                   (0233) ;    The A and X registers may be modified by this or future implementations
                                   (0234) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0235) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0236) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0237) ;    functions.
                                   (0238) ;          
                                   (0239)  I2CHW_1_DisableSlave:
                                   (0240) _I2CHW_1_DisableSlave:
                                   (0241)     RAM_PROLOGUE RAM_USE_CLASS_1
0559: 41 D6 FE AND   REG[214],254  (0242)     BitClrI2CHW_1_CFG I2C_S_EN                                       ;Disable the Slave
                                   (0243)     RAM_EPILOGUE RAM_USE_CLASS_1
055C: 7F       RET                 (0244)     ret
                                   (0245) 
                                   (0246) .ENDSECTION
                                   (0247) 
                                   (0248) .SECTION
                                   (0249) ;-----------------------------------------------------------------------------
                                   (0250) ;  FUNCTION NAME: I2CHW_1_DisableMstr
                                   (0251) ;
                                   (0252) ;  DESCRIPTION:
                                   (0253) ;     Disables I2CHW_1 slave by disabling SDA interrupt
                                   (0254) ;
                                   (0255) ;-----------------------------------------------------------------------------
                                   (0256) ;
                                   (0257) ;  ARGUMENTS: none
                                   (0258) ;
                                   (0259) ;  RETURNS: none
                                   (0260) ;
                                   (0261) ;  SIDE EFFECTS:
                                   (0262) ;    The A and X registers may be modified by this or future implementations
                                   (0263) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0264) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0265) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0266) ;    functions.
                                   (0267) ;          
                                   (0268)  I2CHW_1_DisableMstr:
                                   (0269) _I2CHW_1_DisableMstr:
                                   (0270)     RAM_PROLOGUE RAM_USE_CLASS_1
055D: 41 D6 FD AND   REG[214],253  (0271)     BitClrI2CHW_1_CFG I2C_M_EN                                       ;Disable the Master
                                   (0272)     RAM_EPILOGUE RAM_USE_CLASS_1
0560: 7F       RET                 (0273)    ret

FILE: lib\i2chw_1int.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: I2CHW_1INT.asm
                                   (0004) ;;   Version: 1.5, Updated on 2006/06/06 at 13:39:08
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: I2CHW (Slave) Interrupt Service Routine for the 
                                   (0008) ;;               22/24/27/29xxx PSoC family of devices.
                                   (0009) ;;  This is the interrupt seveice routine for the Slave I2C function.
                                   (0010) ;;-----------------------------------------------------------------------------
                                   (0011) ;;  Copyright (c) Cypress MicroSystems 2000-2006. All Rights Reserved.
                                   (0012) ;;*****************************************************************************
                                   (0013) ;;*****************************************************************************
                                   (0014) include "m8c.inc"
                                   (0015) include "memory.inc"
                                   (0016) include "I2CHW_1Slave.inc"
                                   (0017) include "I2CHW_1Common.inc"
                                   (0018) 
                                   (0019) 
                                   (0020) ;-----------------------------------------------
                                   (0021) ;  Global Symbols
                                   (0022) ;-----------------------------------------------
                                   (0023) export     I2CHW_1_RsrcStatus                                        ; upper (7x) bits write status, lower 3 bits read status
                                   (0024) export    _I2CHW_1_RsrcStatus                                        ; upper (7x) bits write status, lower 3 bits read status
                                   (0025) export     I2CHW_1_Read_Count
                                   (0026) export    _I2CHW_1_Read_Count
                                   (0027) export     I2CHW_1_Write_Count
                                   (0028) export    _I2CHW_1_Write_Count
                                   (0029) export    pI2CHW_1_Read_BufLO
                                   (0030) export   _pI2CHW_1_Read_BufLO
                                   (0031) export    pI2CHW_1_Write_BufLO
                                   (0032) export   _pI2CHW_1_Write_BufLO
                                   (0033) export   _I2CHW_1_bStatus
                                   (0034) export    I2CHW_1_bStatus
                                   (0035) 
                                   (0036) ;-----------------------------------------------
                                   (0037) ; WARNING: The variables below are deprecated
                                   (0038) ; and have been replaced with Read_BufLO
                                   (0039) ; and Write_BufLO
                                   (0040) ;-----------------------------------------------
                                   (0041) export    pI2CHW_1_Read_Buf
                                   (0042) export   _pI2CHW_1_Read_Buf
                                   (0043) export    pI2CHW_1_Write_Buf
                                   (0044) export   _pI2CHW_1_Write_Buf
                                   (0045) ;-----------------------------------------------
                                   (0046) ; END WARNING
                                   (0047) ;-----------------------------------------------
                                   (0048) 
                                   (0049) area InterruptRAM(RAM, REL, CON)	 
                                   (0050) 
                                   (0051) ;-----------------------------------------------
                                   (0052) ; Variable Allocation
                                   (0053) ;-----------------------------------------------
                                   (0054) 
                                   (0055)  _I2CHW_1_bStatus:
                                   (0056)   I2CHW_1_bStatus:                           blk 1
                                   (0057)   I2CHW_1_RsrcStatus:
                                   (0058)  _I2CHW_1_RsrcStatus:                        blk     1
                                   (0059)   I2CHW_1_Write_Count:
                                   (0060)  _I2CHW_1_Write_Count:                       blk    1
                                   (0061) IF SYSTEM_LARGE_MEMORY_MODEL
                                   (0062) export    pI2CHW_1_Write_BufHI
                                   (0063) export   _pI2CHW_1_Write_BufHI
                                   (0064) 
                                   (0065)  pI2CHW_1_Write_BufHI:
                                   (0066) _pI2CHW_1_Write_BufHI:                       blk     1
                                   (0067) ENDIF
                                   (0068) ;-----------------------------------------------
                                   (0069) ; WARNING: The variable below is deprecated
                                   (0070) ; and has been replaced Write_BufLO
                                   (0071) ;-----------------------------------------------
                                   (0072)  pI2CHW_1_Write_Buf:
                                   (0073) _pI2CHW_1_Write_Buf:
                                   (0074) ;-----------------------------------------------
                                   (0075) ; END WARNING
                                   (0076) ;-----------------------------------------------
                                   (0077)  pI2CHW_1_Write_BufLO:
                                   (0078) _pI2CHW_1_Write_BufLO:                       blk      1
                                   (0079) 
                                   (0080) IF I2CHW_1_READ_FLASH
                                   (0081) export    pI2CHW_1_Read_BufHI
                                   (0082) export   _pI2CHW_1_Read_BufHI
                                   (0083) 
                                   (0084)  pI2CHW_1_Read_BufHI:
                                   (0085) _pI2CHW_1_Read_BufHI:                        blk     1
                                   (0086) ELSE
                                   (0087) IF SYSTEM_LARGE_MEMORY_MODEL
                                   (0088) export    pI2CHW_1_Read_BufHI
                                   (0089) export   _pI2CHW_1_Read_BufHI
                                   (0090) 
                                   (0091)  pI2CHW_1_Read_BufHI:
                                   (0092) _pI2CHW_1_Read_BufHI:                        blk     1
                                   (0093) ENDIF
                                   (0094) ENDIF
                                   (0095) 
                                   (0096) ;-----------------------------------------------
                                   (0097) ; WARNING: The variable below is deprecated
                                   (0098) ; and has been replaced Read_BufLO
                                   (0099) ;-----------------------------------------------
                                   (0100)  pI2CHW_1_Read_Buf:
                                   (0101) _pI2CHW_1_Read_Buf:
                                   (0102) ;-----------------------------------------------
                                   (0103) ; END WARNING
                                   (0104) ;-----------------------------------------------
                                   (0105)  pI2CHW_1_Read_BufLO:
                                   (0106) _pI2CHW_1_Read_BufLO:                        blk       1
                                   (0107) 
                                   (0108) IF I2CHW_1_READ_FLASH
                                   (0109) export    I2CHW_1_Read_CountHI
                                   (0110) export   _I2CHW_1_Read_CountHI
                                   (0111) 
                                   (0112)  I2CHW_1_Read_CountHI:
                                   (0113) _I2CHW_1_Read_CountHI:                       blk    1
                                   (0114) ENDIF
                                   (0115) 
                                   (0116)  I2CHW_1_Read_Count:
                                   (0117) _I2CHW_1_Read_Count:                         blk      1
                                   (0118) 
                                   (0119) 
                                   (0120) IF I2CHW_1_POLLED_PROCESS
                                   (0121) 
                                   (0122) I2CHW_1_Poll_Status:                             blk      1  ;internal variable used for polled operation
                                   (0123) ;bit 0 - Write transaction started begin looking for the STOP state to terminate the transaction
                                   (0124) I2C_WRITE_STARTED:       equ     0x01
                                   (0125) ;bit 1 - Undefined
                                   (0126) ;bit 2 - Undefined
                                   (0127) ;bit 3 - Undefined
                                   (0128) ;bit 4 - Undefined
                                   (0129) ;bit 5 - Undefined
                                   (0130) ;bit 6 - Undefined
                                   (0131) ;bit 7 - Undefined
                                   (0132) 
                                   (0133) ENDIF
                                   (0134) 
                                   (0135) 
                                   (0136) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                   (0137) ;---------------------------------------------------
                                   (0138) ; Insert your custom declarations below this banner
                                   (0139) ;---------------------------------------------------
                                   (0140) 
                                   (0141) ;------------------------
                                   (0142) ; Includes
                                   (0143) ;------------------------
                                   (0144) 
                                   (0145) 	
                                   (0146) ;------------------------
                                   (0147) ;  Constant Definitions
                                   (0148) ;------------------------
                                   (0149) 
                                   (0150) 
                                   (0151) ;------------------------
                                   (0152) ; Variable Allocation
                                   (0153) ;------------------------
                                   (0154) 
                                   (0155) 
                                   (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations above this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0160) 
                                   (0161) 
                                   (0162) 
                                   (0163) 
                                   (0164) AREA UserModules (ROM, REL)
                                   (0165) 
                                   (0166) export _I2CHW_1_ISR
                                   (0167) export _I2CHW_1_Poll
                                   (0168) export  I2CHW_1_Poll
                                   (0169) 
                                   (0170) ;;****************************************************
                                   (0171) ;; I2C_ISR  main entry point from vector 60h
                                   (0172) ;;
                                   (0173) ;;****************************************************
                                   (0174) 
                                   (0175) IF I2CHW_1_POLLED_PROCESS
                                   (0176) 
                                   (0177) _I2CHW_1_ISR:
                                   (0178)     reti ; stub out the ISR if this is going to be a polled function
                                   (0179) 
                                   (0180)  
                                   (0181)  
                                   (0182)  I2CHW_1_Poll:
                                   (0183) _I2CHW_1_Poll:
                                   (0184) ;    cases are:
                                   (0185) ;    1. Stop state after a Master write to this slave
                                   (0186) ;    2. possible Stop condition COMBINED with a new transaction is not a problem since the Stop will only flag that the 
                                   (0187) ;       previous write has been completed. (so just call the I2CA_Process routine for this case and let the process routine take
                                   (0188) ;       care of it.
                                   (0189)     ;case 1
                                   (0190)     RAM_SETPAGE_CUR	( >I2CHW_1_Poll_Status )
                                   (0191) 
                                   (0192)     tst [I2CHW_1_Poll_Status], I2C_WRITE_STARTED
                                   (0193)     jz  NOT_I2C_Write
                                   (0194)     tst reg[ I2CHW_1_SCR], I2C_STOP_ST
                                   (0195)     jz  NOT_I2C_Write
                                   (0196)     ;make sure the pushes and pops 'line up' or die horribly
                                   (0197)     push A
                                   (0198)     push X
                                   (0199) IF SYSTEM_LARGE_MEMORY_MODEL
                                   (0200)     REG_PRESERVE IDX_PP
                                   (0201) ENDIF
                                   (0202)     jmp STOPTRAP
                                   (0203)     
                                   (0204) NOT_I2C_Write:    
                                   (0205)     tst reg[ I2CHW_1_SCR], I2C_BYTE_COMPL
                                   (0206)     jnz  I2CHW_1_Process   ;if no other critical eventa are in evidence, process an I2C byte if it's done
                                   (0207)     ret
                                   (0208) 
                                   (0209)  I2CHW_1_Process:
                                   (0210) _I2CHW_1_Process:  ;don't need to export user will call I2CA_POLL which will call the I2CA_Process routine if necessary
                                   (0211) 
                                   (0212) 
                                   (0213) 
                                   (0214) ELSE
                                   (0215) ;; STUB for polling function when it's un-defined
                                   (0216)  I2CHW_1_Poll:
                                   (0217) _I2CHW_1_Poll:
0561: 7F       RET                 (0218)     ret
                                   (0219) 
                                   (0220) 
                                   (0221) ;;*****************************************************************************************
                                   (0222) ;;                 I2C_MASTER  main entry point from vector 60h
                                   (0223) ;;*****************************************************************************************
                                   (0224) 
                                   (0225) _I2CHW_1_ISR:
                                   (0226) ENDIF
0562: 08       PUSH  A             (0227)     push A
0563: 10       PUSH  X             (0228)     push X
0564: 5D D3    MOV   A,REG[211]
                                   (0229) 
                                   (0230) IF SYSTEM_LARGE_MEMORY_MODEL
0566: 08       PUSH  A             (0231)     REG_PRESERVE IDX_PP
                                   (0232) ENDIF
                                   (0233) 
                                   (0234) Process_REENTRY:
                                   (0235) 
                                   (0236) ;******************************************************************************************
                                   (0237) ;Before doing anything else check for the presence of a STOP_ST in combination with the
                                   (0238) ;STOP Interrupt Enable (STOPIE).  If this is what happened set appropriate bits, 
                                   (0239) ;clear and reset the main I2CHW interrupt to assure that we haven't missed a BYTE_COMPLETE
                                   (0240) ;interrupt and exit the interrupt.  If a BYTE_COMPLETE interrupt is concurrent with the STOP 
                                   (0241) ;interrupt the next entry to this interrupt will be immediate and the STOPIE bit will now be 
                                   (0242) ;cleared.  This removes the possibility of trying to process two different events within one 
                                   (0243) ;interrupt.
                                   (0244) ;          
                                   (0245) ;******************************************************************************************
                                   (0246) ; Check the Stop Bit in SCR only if the Stop Interrupt is enabled.    
                                   (0247) 
0567: 49 D6 10 TST   REG[214],16   (0248)     tst reg[I2CHW_1_CFG],I2C_STOPIE
056A: A0 06    JZ    0x0571        (0249)     jz  ByteComplProcess
056C: 49 D7 20 TST   REG[215],32   (0250)     tst reg[I2CHW_1_SCR],I2C_STOP_ST                         ; Test if the Interrupt is due to Stop Condition
                                   (0251) ;conditions that must be met here are Slave-enabled, STOP int enabled (STOPIE), and STOP_ST (status bit set)
056F: B0 EB    JNZ   0x065B        (0252)     jnz STOPTRAP                                       ; If yes process Stop Trap
                                   (0253) 
                                   (0254) ByteComplProcess:
                                   (0255) ;*********END TEST OF STOP STATUS**********************************************************       
                                   (0256) 
                                   (0257) ;       file stored in Slave directory of user module
                                   (0258) ;program flow would likely be to first determine what 'mode' the device is in.  I.e. is Master and Slave mode enabled?
                                   (0259) ; control of program flow must take more into account when all more modes are enabled.
                                   (0260) ;
                                   (0261) ;* Slave only
                                   (0262)     ;very first thing to test is the I2C_ADDRIN bit.  If set then we are getting an address after a START
0571: 49 D7 08 TST   REG[215],8    (0263)     tst reg[I2CHW_1_SCR], I2C_ADDRIN
0574: B0 74    JNZ   0x05E9        (0264)     jnz I2C_EvaluateADDRIN
                                   (0265) 
                                   (0266)     ; if slave didn't recieve an address, then this must be data for it to deal with
0576: 49 D7 04 TST   REG[215],4    (0267)     tst reg[I2CHW_1_SCR], I2C_TX  ;if set we are transmitting => this is at end of byte to eval the ACK
0579: B0 BE    JNZ   0x0638        (0268)     jnz I2C_EvaluateACKIN
                                   (0269)     ; if slave NOT transmitting and NOT an address then data is being recieved
                                   (0270)     ; ack it and process it.
                                   (0271) 
                                   (0272)     ;UNLESS the stop bit turns out to have been set...
057B: 49 D7 20 TST   REG[215],32   (0273)     tst reg[I2CHW_1_SCR], I2C_STOP_ST
057E: B0 DC    JNZ   0x065B        (0274)     jnz STOPTRAP
                                   (0275)     ; if slave NOT transmitting and NOT an address and Master is NOT terminating the then data is being recieved
                                   (0276)     ; ack it and process it.
                                   (0277) 
                                   (0278) ;;code snipped from old SW I2C below
                                   (0279) ;
                                   (0280) ; MASTER WRITE to SLAVE
                                   (0281) ;
                                   (0282) ;@PSoC_UserCode_BODY1@ (Do not change this line.)
                                   (0283) ;---------------------------------------------------
                                   (0284) ; Insert your custom code below this banner
                                   (0285) ;---------------------------------------------------
                                   (0286) ; By modifying the section from here down to the next comment block
                                   (0287) ; a user could process data for a custom I2C WRITE application
                                   (0288) ; NOTE: I2C handshakes (ACK/NAK may be effected by any introduced bugs)
                                   (0289) ;********************************************************
0580: 47 0A 04 TST   [10],4        (0290)    tst   [I2CHW_1_bStatus], fI2C_NAKnextWr
0583: B0 14    JNZ   0x0598        (0291)    jnz   WrStoreData
                                   (0292)    ;
                                   (0293)    ;process write data here
                                   (0294)    ;
0585: 7A 0C    DEC   [12]          (0295)    dec   [I2CHW_1_Write_Count]
0587: C0 39    JC    0x05C1        (0296)    jc    I2CHW_1_WriteOverflow                                       ; carry set if value became -1
                                   (0297)    ;jz    WrStoreData
0589: 3C 0C 00 CMP   [12],0        (0298)    cmp   [I2CHW_1_Write_Count], 00                                   ;set nak flag, dec count, and store data
058C: A0 03    JZ    0x0590        (0299)    jz    WrNakNextByte
058E: 80 06    JMP   0x0595        (0300)    jmp   WrNotBufEnd
                                   (0301) WrNakNextByte:                                                       ;set the nakflag in I2CHW_1_bStatus
0590: 2E 0A 04 OR    [10],4        (0302)    or    [I2CHW_1_bStatus], fI2C_NAKnextWr
0593: 80 04    JMP   0x0598        (0303)    jmp   WrStoreData
                                   (0304) WrNotBufEnd:
0595: 26 0A FB AND   [10],251      (0305)    and   [I2CHW_1_bStatus], ~fI2C_NAKnextWr                          ;clear the nak flag in case it was set from a previous operation
                                   (0306) WrStoreData:
                                   (0307)    ;This is the ONLY place this bit is set  This bit should never be cleared by the isr ONLY by the API ClrWrStatus()
0598: 2E 0B 10 OR    [11],16       (0308)    or    [I2CHW_1_RsrcStatus], I2CHW_WR_NOERR                        ;set current status
                                   (0309) IF SYSTEM_LARGE_MEMORY_MODEL
059B: 51 0D    MOV   A,[13]        (0310)    mov   A, [pI2CHW_1_Write_BufHI]
                                   (0311) ENDIF
059D: 60 D3    MOV   REG[211],A    (0312)    RAM_SETPAGE_IDX A
059F: 58 0E    MOV   X,[14]        (0313)    mov   X, [pI2CHW_1_Write_BufLO]
05A1: 5D D8    MOV   A,REG[216]    (0314)    mov   A, reg[I2CHW_1_DR]
05A3: 70 3F    AND   F,63
05A5: 71 80    OR    F,128         (0315)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
05A7: 54 00    MOV   [X+0],A       (0316)    mov   [X], A
05A9: 70 3F    AND   F,63
05AB: 71 00    OR    F,0           (0317)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
05AD: 76 0E    INC   [14]          (0318)    inc   [pI2CHW_1_Write_BufLO]
                                   (0319) 
05AF: 47 0A 04 TST   [10],4        (0320)    tst   [I2CHW_1_bStatus], fI2C_NAKnextWr
05B2: B0 16    JNZ   0x05C9        (0321)    jnz   NAK_this_one
                                   (0322) 
                                   (0323) 
                                   (0324) ;---------------------------------------------------
                                   (0325) ; End user I2C WRITE Customization
                                   (0326) ; Insert your custom code above this banner
                                   (0327) ;---------------------------------------------------
                                   (0328) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0329) ;;code snipped form SW I2C to maintain api compatibility above
                                   (0330) 
                                   (0331) ;
                                   (0332) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                   (0333) ;
05B4: 62 D7 10 MOV   REG[215],16   (0334)     SetI2CHW_1_SCR  (I2C_ACKOUT )
05B7: 18       POP   A
                                   (0335) 
                                   (0336) 
                                   (0337) IF SYSTEM_LARGE_MEMORY_MODEL
05B8: 60 D3    MOV   REG[211],A    (0338)     REG_RESTORE IDX_PP
                                   (0339) ENDIF
05BA: 20       POP   X             (0340)     pop X
05BB: 18       POP   A             (0341)     pop A
05BC: 70 3F    AND   F,63
05BE: 71 C0    OR    F,192         (0342)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
05C0: 7E       RETI                (0343)     I2CHW_1_SERVICE_RETURN
                                   (0344) 
                                   (0345) 
                                   (0346) ;
                                   (0347) ;ram-write-overflow label here, just rewrite the last location in the buffer
                                   (0348) ;    and set the overflow flag
                                   (0349) ;
                                   (0350) I2CHW_1_WriteOverflow:
05C1: 2E 0B 20 OR    [11],32       (0351)    or    [I2CHW_1_RsrcStatus], I2CHW_WR_OVERFLOW                     ; flag the overflow
05C4: 26 0B EF AND   [11],239      (0352)    and   [I2CHW_1_RsrcStatus], ~I2CHW_WR_NOERR
05C7: 76 0C    INC   [12]          (0353)    inc   [I2CHW_1_Write_Count]                                       ; put it back to zero
                                   (0354)    ;If data is to be Nak'ed
                                   (0355) NAK_this_one:
05C9: 26 0A FB AND   [10],251      (0356)    and   [I2CHW_1_bStatus], ~fI2C_NAKnextWr                          ;clear the nak flag in case it was set from a previous operation
                                   (0357) 
                                   (0358) ;
                                   (0359) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                   (0360) ;
05CC: 62 D7 00 MOV   REG[215],0    (0361)     SetI2CHW_1_SCR ( 0 )
05CF: 18       POP   A
                                   (0362) 
                                   (0363) 
                                   (0364) IF SYSTEM_LARGE_MEMORY_MODEL
05D0: 60 D3    MOV   REG[211],A    (0365)     REG_RESTORE IDX_PP
                                   (0366) ENDIF
05D2: 20       POP   X             (0367)     pop X
05D3: 18       POP   A             (0368)     pop A
05D4: 70 3F    AND   F,63
05D6: 71 C0    OR    F,192         (0369)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
05D8: 7E       RETI                (0370)     I2CHW_1_SERVICE_RETURN                                                              ;return and wait for the next interrupt (on data)
                                   (0371) 
                                   (0372) 
                                   (0373) ;********************************************************
                                   (0374) ; Treat the case where the Slave will be continuing to
                                   (0375) ; receive data after receiving the address
                                   (0376) ;********************************************************
                                   (0377) I2C_AckAddr_RXdata:
                                   (0378) IF I2CHW_1_POLLED_PROCESS
                                   (0379)     or [I2CHW_1_Poll_Status], I2C_WRITE_STARTED
                                   (0380) ELSE
05D9: 43 D6 10 OR    REG[214],16   (0381)     BitSetI2CHW_1_CFG ( I2C_STOPIE )
                                   (0382) ENDIF
                                   (0383) 
                                   (0384) ;
                                   (0385) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                   (0386) ;
05DC: 62 D7 10 MOV   REG[215],16   (0387)     SetI2CHW_1_SCR ( I2C_ACKOUT )
05DF: 18       POP   A
                                   (0388) 
                                   (0389) 
                                   (0390) IF SYSTEM_LARGE_MEMORY_MODEL
05E0: 60 D3    MOV   REG[211],A    (0391)     REG_RESTORE IDX_PP
                                   (0392) ENDIF
05E2: 20       POP   X             (0393)     pop X
05E3: 18       POP   A             (0394)     pop A
05E4: 70 3F    AND   F,63
05E6: 71 C0    OR    F,192         (0395)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
05E8: 7E       RETI                (0396)     I2CHW_1_SERVICE_RETURN
                                   (0397) 
                                   (0398) ;********************************************************
                                   (0399) ; Look to see if the address is us or someone else
                                   (0400) ; use the carry flag to idendify a READ or WRITE address
                                   (0401) ;********************************************************
                                   (0402) I2C_EvaluateADDRIN:
05E9: 51 0B    MOV   A,[11]        (0403)     mov A, [I2CHW_1_RsrcStatus]
05EB: 21 30    AND   A,48          (0404)     and A, (I2CHW_WR_NOERR | I2CHW_WR_OVERFLOW)
05ED: A0 07    JZ    0x05F5        (0405)     jz  NewADDRNotSet                                                                                             ;set new addr only if previous data appears to be in buffer
05EF: 2E 0B 40 OR    [11],64       (0406)     or  [I2CHW_1_RsrcStatus], I2CHW_WR_COMPLETE                      ;Same bit as I2CHW_ISR_NEW_ADDR
                                   (0407) 
                                   (0408) IF I2CHW_1_POLLED_PROCESS						                              ;if a new addr was received it's OK to terminate stop detection
                                   (0409)     and [I2CHW_1_Poll_Status], ~I2C_WRITE_STARTED            ;used to determine the end of a Master write to a slave.
                                   (0410) ELSE													                                            ;A REPEAT START could have terminated the transaction without a STOP
05F2: 41 D6 EF AND   REG[214],239  (0411)     BitClrI2CHW_1_CFG I2C_STOPIE
                                   (0412) ENDIF
                                   (0413)                                                                                                                                           ;SET WR_COMPL bit if it appears there was write taking place just previous
                                   (0414) NewADDRNotSet:                                                       ;may use as a way to tag the end of a master write to slave
                                   (0415) ;@PSoC_UserCode_BODY4@ (Do not change this line.)
                                   (0416) ;---------------------------------------------------
                                   (0417) ; Insert your custom code below this banner
                                   (0418) ;---------------------------------------------------
                                   (0419) ; By replacing the section from here down to the next block
                                   (0420) ; a user could process I2C addresses differently
                                   (0421) ;********************************************************
                                   (0422)                                                                                                                                           ;to this new address by looking at the status bits
                                   (0423)     ;inc [rec_cnt]
05F5: 5D D8    MOV   A,REG[216]    (0424)     mov A, reg[I2CHW_1_DR]
05F7: 70 F9    AND   F,249         (0425)     and F, 0xF9                                                      ;clear Carry (C) AND Zero (Z) in Flag reg
05F9: 6D       RRC   A             (0426)     rrc A                                                            ;carry now holds bit 0 (r/~w) from addr byte
05FA: 31 11    XOR   A,17          (0427)     xor A,  I2CHW_1_SLAVE_ADDR                                       ;for an equate
                                   (0428) 
05FC: B0 4E    JNZ   0x064B        (0429)     jnz I2C_Terminate
05FE: 2E 0B 80 OR    [11],128      (0430)     or [I2CHW_1_RsrcStatus], I2CHW_ISR_ACTIVE
                                   (0431) 
                                   (0432) ;********************************************************
                                   (0433) ; User could modify this section to allow the I2C routine
                                   (0434) ; to respond to multiple addresses, ram addresses, i/o pin
                                   (0435) ; based addresses, etc.
                                   (0436) ;********************************************************
                                   (0437) ;---------------------------------------------------
                                   (0438) ; End user I2C ADDR Compare Customization
                                   (0439) ; Insert your custom code above this banner
                                   (0440) ;---------------------------------------------------
                                   (0441) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0442) 
                                   (0443) I2CHW_1_send_ack:                                                    ;slave send adress ack
                                   (0444) 
                                   (0445) 
                                   (0446)     ;OK so the addreses were the same was it a read (c=1) or a write (c=0)
0601: DF D7    JNC   0x05D9        (0447)     jnc I2C_AckAddr_RXdata ;(Master Write/Slave Receive) for this case we receive data and ack it
                                   (0448) 
                                   (0449) ;********************************************************
                                   (0450) ;Master Read (Master Read/Slave Transmit) Ack the address too.
                                   (0451) ;for this case the master has just sent us OUR read address which must be Ack'ed and will
                                   (0452) ;subsequently be reading from us (which the master will Ack.  So for the first bit we must
                                   (0453) ; set the I2C_TX AND the ACK bits in the I2C_SCR (first byte only)
                                   (0454) ; THEN we'll just be reading the ACK from the master as it reads our data
                                   (0455) ;********************************************************
                                   (0456) 
0603: 26 0B FB AND   [11],251      (0457)     and [I2CHW_1_RsrcStatus], ~I2CHW_RD_COMPLETE                     ;Master will NAK us at the end of transaction
                                   (0458) 
0606: 50 14    MOV   A,20          (0459)     mov A, (I2C_ACKOUT | I2C_TX)
0608: 08       PUSH  A             (0460)     push A
                                   (0461) 
                                   (0462) 
                                   (0463) ;
                                   (0464) ;MASTER is READING FROM SLAVE (ram or flash buffer)
                                   (0465) ;
                                   (0466) ;;code snipped from old SW I2C below
                                   (0467) 
                                   (0468) I2C_ObtainReadData:
                                   (0469) 
                                   (0470) ;********************************************************
                                   (0471) ; here we need to get the next data to output (master-read)
                                   (0472) ; also set the status byte for use on exit
                                   (0473) ;********************************************************
                                   (0474) IF I2CHW_1_READ_FLASH
                                   (0475) ;@PSoC_UserCode_BODY2@ (Do not change this line.)
                                   (0476) ;---------------------------------------------------
                                   (0477) ; Insert your custom code below this banner
                                   (0478) ; User flash read customization could take place within
                                   (0479) ; this area
                                   (0480) ;---------------------------------------------------
                                   (0481)     tst  [I2CHW_1_RsrcStatus],I2CHW_READFLASH
                                   (0482)     jz   ReadRamData
                                   (0483) 
                                   (0484)     ;
                                   (0485)     ;get the data
                                   (0486)     ;
                                   (0487)     mov  X, [pI2CHW_1_Read_BufLO]
                                   (0488)     mov  A, [pI2CHW_1_Read_BufHI]
                                   (0489)     romx
                                   (0490)     mov  reg[I2CHW_1_DR],A
                                   (0491)     dec  [I2CHW_1_Read_Count]                                        ;calc addr lsb
                                   (0492)     jnc  NoDecHighCount
                                   (0493)     dec  [I2CHW_1_Read_CountHI]
                                   (0494)     jc   FlashRdOverflow
                                   (0495) 
                                   (0496) NoDecHighCount:
                                   (0497) 
                                   (0498)     inc  [pI2CHW_1_Read_BufLO]                                       ;set the next flash address to read
                                   (0499)     jnc  NoIncHiAddr
                                   (0500)     inc  [pI2CHW_1_Read_BufHI]
                                   (0501) NoIncHiAddr:
                                   (0502)    jmp   I2CNormalRead
                                   (0503) 
                                   (0504) FlashRdOverflow:
                                   (0505)     ;deal with the over flow cond by resending last data byte (dec the low order addr byte)
                                   (0506) 
                                   (0507)    or    [I2CHW_1_RsrcStatus], I2CHW_RD_OVERFLOW
                                   (0508)    and   [I2CHW_1_RsrcStatus], ~I2CHW_RD_NOERR
                                   (0509)    ;set count back to 0
                                   (0510)    mov   [I2CHW_1_Read_CountHI], 0                                   ;functionally the same as incrementing ffff and less instructions
                                   (0511)    mov   [I2CHW_1_Read_Count], 0
                                   (0512)    jmp   I2CNormalRead
                                   (0513) ;---------------------------------------------------
                                   (0514) ; Insert your custom code above this banner
                                   (0515) ; END User flash read customization
                                   (0516) ;---------------------------------------------------
                                   (0517) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0518) ENDIF
                                   (0519) ;@PSoC_UserCode_BODY3@ (Do not change this line.)
                                   (0520) ;---------------------------------------------------
                                   (0521) ; Insert your custom code below this banner
                                   (0522) ;---------------------------------------------------
                                   (0523) ; By replacing the section from here down to the next block
                                   (0524) ; a user could process data for a custom I2C READ application
                                   (0525) ;********************************************************
                                   (0526) ReadRamData:
                                   (0527)    ;read the current data byte
                                   (0528) IF SYSTEM_LARGE_MEMORY_MODEL
0609: 51 0F    MOV   A,[15]        (0529)    mov   A, [pI2CHW_1_Read_BufHI]
                                   (0530) ENDIF
060B: 60 D3    MOV   REG[211],A    (0531)    RAM_SETPAGE_IDX A
060D: 58 10    MOV   X,[16]        (0532)    mov   X, [pI2CHW_1_Read_BufLO]
060F: 70 3F    AND   F,63
0611: 71 80    OR    F,128         (0533)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
0613: 52 00    MOV   A,[X+0]       (0534)    mov   A, [X]
0615: 70 3F    AND   F,63
0617: 71 00    OR    F,0           (0535)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0619: 60 D8    MOV   REG[216],A    (0536)    mov   reg[I2CHW_1_DR], A
061B: 7A 11    DEC   [17]          (0537)    dec   [I2CHW_1_Read_Count]
061D: C0 05    JC    0x0623        (0538)    jc    I2CHW_1_readOverflow
061F: 76 10    INC   [16]          (0539)    inc   [pI2CHW_1_Read_BufLO]
0621: 80 09    JMP   0x062B        (0540)    jmp   I2CNormalRead
                                   (0541) ;
                                   (0542) ;ram read overflow detected here, just resend the last location in the buffer
                                   (0543) ;
                                   (0544) I2CHW_1_readOverflow:
0623: 2E 0B 02 OR    [11],2        (0545)    or    [I2CHW_1_RsrcStatus], I2CHW_RD_OVERFLOW
0626: 26 0B FE AND   [11],254      (0546)    and   [I2CHW_1_RsrcStatus], ~I2CHW_RD_NOERR
0629: 76 11    INC   [17]          (0547)    inc   [I2CHW_1_Read_Count]                                        ; set back to zero
                                   (0548) 
                                   (0549) ;********************************************************
                                   (0550) ; End user I2C READ customization section
                                   (0551) ;********************************************************
                                   (0552) ; Insert your custom code above this banner
                                   (0553) ;---------------------------------------------------
                                   (0554) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0555) 
                                   (0556) ;;code snipped form SW I2C to maintain api compatibility above
                                   (0557) I2CNormalRead:
                                   (0558) 
                                   (0559)         ;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
                                   (0560)         ;and place there based on whether or not the previous transmission was our I2C address.
062B: 18       POP   A             (0561)         pop A
                                   (0562) 
                                   (0563) ;
                                   (0564) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                   (0565) ;
062C: 60 D7    MOV   REG[215],A    (0566)     SetI2CHW_1_SCR A     ;set read bit as (bit0) and Addr bit (bit7)in the I2C_SCR
062E: 18       POP   A
                                   (0567) 
                                   (0568) 
                                   (0569) IF SYSTEM_LARGE_MEMORY_MODEL
062F: 60 D3    MOV   REG[211],A    (0570)     REG_RESTORE IDX_PP
                                   (0571) ENDIF
0631: 20       POP   X             (0572)     pop X
0632: 18       POP   A             (0573)     pop A
0633: 70 3F    AND   F,63
0635: 71 C0    OR    F,192         (0574)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
0637: 7E       RETI                (0575)     I2CHW_1_SERVICE_RETURN ;return and wait for the next interrupt (on data)
                                   (0576) 
                                   (0577) 
                                   (0578) 
                                   (0579) I2C_EvaluateACKIN:
                                   (0580) 
0638: 49 D7 02 TST   REG[215],2    (0581)     tst reg[I2CHW_1_SCR], I2C_LST_BIT
063B: B0 06    JNZ   0x0642        (0582)     jnz I2C_LastByteToMstr  ;NAK recd on TX so this is the end set mode to interrup only on ADDR IN
                                   (0583)     ; got here we were ACK'ed so send another byte
063D: 50 04    MOV   A,4           (0584)     mov A, ( I2C_TX )
                                   (0585)         ;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
                                   (0586)         ;and place there based on whether or not the previous transmission was our I2C address.
063F: 08       PUSH  A             (0587)         push A
0640: 8F C8    JMP   0x0609        (0588)         jmp I2C_ObtainReadData
                                   (0589) 
                                   (0590) 
                                   (0591) I2C_LastByteToMstr:
0642: 2E 0B 01 OR    [11],1        (0592)     or  [I2CHW_1_RsrcStatus], I2CHW_RD_NOERR                         ;Master NAK'ed us at the end of transaction
0645: 2E 0B 04 OR    [11],4        (0593)     or  [I2CHW_1_RsrcStatus], I2CHW_RD_COMPLETE
0648: 26 0B 7F AND   [11],127      (0594)     and [I2CHW_1_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                   (0595) 
                                   (0596) I2C_Terminate:
064B: 26 0B 7F AND   [11],127      (0597)     and [I2CHW_1_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                   (0598) 
                                   (0599) ;
                                   (0600) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                   (0601) ;
064E: 62 D7 00 MOV   REG[215],0    (0602)     SetI2CHW_1_SCR 0     ;the default mode to wait for an address
0651: 18       POP   A
                                   (0603) 
                                   (0604) 
                                   (0605) IF SYSTEM_LARGE_MEMORY_MODEL
0652: 60 D3    MOV   REG[211],A    (0606)     REG_RESTORE IDX_PP
                                   (0607) ENDIF
0654: 20       POP   X             (0608)     pop X
0655: 18       POP   A             (0609)     pop A
0656: 70 3F    AND   F,63
0658: 71 C0    OR    F,192         (0610)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
065A: 7E       RETI                (0611)     I2CHW_1_SERVICE_RETURN
                                   (0612) 
                                   (0613) STOPTRAP:
                                   (0614)     ;I2C stop detected
                                   (0615) ;
                                   (0616) ; set a flag to indicate END OF TRANSMISSION
                                   (0617) ;
065B: 2E 0B 40 OR    [11],64       (0618)     or  [I2CHW_1_RsrcStatus], I2CHW_WR_COMPLETE                      ;only SET by ISR USER must clear.
065E: 26 0B 7F AND   [11],127      (0619)     and [I2CHW_1_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                   (0620) 
                                   (0621) IF I2CHW_1_POLLED_PROCESS
                                   (0622)     and [I2CHW_1_Poll_Status], ~I2C_WRITE_STARTED
                                   (0623) 	jmp ExitISR
                                   (0624) ELSE
0661: 41 D6 EF AND   REG[214],239  (0625)     BitClrI2CHW_1_CFG I2C_STOPIE
0664: 49 D7 01 TST   REG[215],1    (0626)     tst reg[I2CHW_1_SCR], I2C_BYTE_COMPL
                                   (0627) ;;if BYTE_COMPL is set, there's an excellent chance to lose an ISR.  Because of the way they are
                                   (0628) ;; latched into the INT_MSK.  Therefore clear the applicable bit (STOPIE) and jump directly to the 
                                   (0629) ;; top of this routing since the bus is currently stalled.  Just in case the ISR is properly latched,
                                   (0630) ;; clear the mask bit since it's is serviced manually.
0667: A0 06    JZ    0x066E        (0631)     jz ExitISR
0669: 41 DD FE AND   REG[221],254  (0632)     and  reg[INT_CLR3], ~0x01                                ;clear the I2C interrupt
                                   (0633) ENDIF
                                   (0634) 
066C: 8E FA    JMP   0x0567        (0635) 	jmp Process_REENTRY
066E: 18       POP   A
                                   (0636) 
                                   (0637) ExitISR:
                                   (0638) 
                                   (0639) IF SYSTEM_LARGE_MEMORY_MODEL
066F: 60 D3    MOV   REG[211],A    (0640)     REG_RESTORE IDX_PP
                                   (0641) ENDIF
0671: 20       POP   X             (0642)     pop X
0672: 18       POP   A             (0643)     pop A
0673: 70 3F    AND   F,63
0675: 71 C0    OR    F,192         (0644)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
0677: 7E       RETI                (0645)     I2CHW_1_SERVICE_RETURN

FILE: lib\i2chw_1common.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: I2CHW_1Common.asm
                                   (0004) ;;   Version: 1.5, Updated on 2006/06/06 at 13:39:08
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: I2Cs User Module software implementation file
                                   (0008) ;;               for the (22/24/27/29xxx) PSoC family of devices
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress MicroSystems 2002-2006. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "memory.inc"
                                   (0025) include "I2CHW_1Common.inc"
                                   (0026) 
                                   (0027) ;-----------------------------------------------
                                   (0028) ; include instance specific register definitions
                                   (0029) ;-----------------------------------------------
                                   (0030) 
                                   (0031) ;-----------------------------------------------
                                   (0032) ;  Global Symbols
                                   (0033) ;-----------------------------------------------
                                   (0034) ;-------------------------------------------------------------------
                                   (0035) ;  Declare the functions global for both assembler and C compiler.
                                   (0036) ;
                                   (0037) ;  Note that there are two names for each API. First name is
                                   (0038) ;  assembler reference. Name with underscore is name refence for
                                   (0039) ;  C compiler.  Calling function in C source code does not require
                                   (0040) ;  the underscore.
                                   (0041) ;-------------------------------------------------------------------
                                   (0042) 
                                   (0043) export    I2CHW_1_InitWrite
                                   (0044) export   _I2CHW_1_InitWrite
                                   (0045) export    I2CHW_1_InitRamRead
                                   (0046) export   _I2CHW_1_InitRamRead
                                   (0047) export    I2CHW_1_InitFlashRead
                                   (0048) export   _I2CHW_1_InitFlashRead
                                   (0049) export    I2CHW_1_bReadI2CStatus
                                   (0050) export   _I2CHW_1_bReadI2CStatus
                                   (0051) export    I2CHW_1_ClrRdStatus
                                   (0052) export   _I2CHW_1_ClrRdStatus
                                   (0053) export    I2CHW_1_ClrWrStatus
                                   (0054) export   _I2CHW_1_ClrWrStatus
                                   (0055) 
                                   (0056) 
                                   (0057) AREA UserModules (ROM, REL)
                                   (0058) 
                                   (0059) 
                                   (0060) .SECTION
                                   (0061) ;-----------------------------------------------------------------------------
                                   (0062) ;  FUNCTION NAME: I2CHW_1_InitWrite
                                   (0063) ;
                                   (0064) ;  DESCRIPTION:
                                   (0065) ;     Initializes a data buffer pointer for the slave to use to deposit data, and
                                   (0066) ;     zeroes the value of a count byte for the same buffer.
                                   (0067) ;
                                   (0068) ;-----------------------------------------------------------------------------
                                   (0069) ;
                                   (0070) ;  ARGUMENTS:  [SP-5]   -- count of bytes to write
                                   (0071) ;              [SP-4]   -- Hi order part of address Wrbuf
                                   (0072) ;              [SP-3]   -- Low order part of the address Wrbuf 
                                   (0073) ;
                                   (0074) ;  RETURNS:  none
                                   (0075) ;
                                   (0076) ;    Write Status bits are cleared
                                   (0077) ;
                                   (0078) ;  SIDE EFFECTS:
                                   (0079) ;    The A and X registers may be modified by this or future implementations
                                   (0080) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0081) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0082) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0083) ;    functions.
                                   (0084) ;          
                                   (0085) ;    Currently only the page pointer registers listed below are modified: 
                                   (0086) ;          CUR_PP
                                   (0087) ;
                                   (0088) ;    Write Status bits are cleared
                                   (0089) ;
                                   (0090) ;  THEORY of OPERATION or PROCEDURE:
                                   (0091) ;     The C compiler will always place a 0 (the upper order byte of the address pointer) in
                                   (0092) ;     the accumulator.  X register is the low order pointer.
                                   (0093) ;     IF a one byte buffer is established, set a flag to NAK the first written data byte.
                                   (0094) ;
                                   (0095) 
                                   (0096)  I2CHW_1_InitWrite:
                                   (0097) _I2CHW_1_InitWrite:
                                   (0098) 
                                   (0099) WrCnt:   equ -5
                                   (0100) WrBufHi: equ -4
                                   (0101) WrBufLo: equ -3
                                   (0102) 
                                   (0103) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0104)     RAM_PROLOGUE RAM_USE_CLASS_2
0678: 10       PUSH  X             (0105) 	push  X
0679: 4F       MOV   X,SP          (0106) 	mov   X, SP
067A: 79       DEC   X             (0107)     dec   X                                                          ;set up the pointer for correct param access
067B: 08       PUSH  A             (0108)     push  A
067C: 5D DE    MOV   A,REG[222]    (0109)     mov   A, reg[INT_MSK3]
067E: 08       PUSH  A             (0110)     push  A                                                           ;preserve flags prior to disabling int
067F: 41 DE FE AND   REG[222],254  (0111)     M8C_DisableIntMask INT_MSK3, INT_MSK3_I2C
                                   (0112) 
0682: 62 D0 00 MOV   REG[208],0    (0113)     RAM_SETPAGE_CUR >I2CHW_1_bStatus						                           ;Set the Page Pointer for LMM
0685: 26 0A FB AND   [10],251      (0114)     and    [I2CHW_1_bStatus], ~fI2C_NAKnextWr                        ;reset the nak-next-written-byte flag.
                                   (0115) IF SYSTEM_LARGE_MEMORY_MODEL
0688: 52 FC    MOV   A,[X-4]       (0116)     mov   A, [X + WrBufHi]                                           ;move wrbuf addr to A
068A: 53 0D    MOV   [13],A        (0117)     mov   [pI2CHW_1_Write_BufHI], A
                                   (0118) ENDIF
068C: 52 FD    MOV   A,[X-3]       (0119)     mov   A, [X + WrBufLo]                                           ;move wrbuf addr to A
068E: 53 0E    MOV   [14],A        (0120)     mov   [pI2CHW_1_Write_BufLO], A
0690: 52 FB    MOV   A,[X-5]       (0121)     mov   A, [X + WrCnt]                                               ;move Write_count to A
0692: 53 0C    MOV   [12],A        (0122)     mov   [I2CHW_1_Write_Count], A
0694: 39 01    CMP   A,1           (0123)     cmp   A, 01                                                        ;if data buffer is one byte long or less
0696: A0 08    JZ    0x069F        (0124)     jz    I2CHW_1_SetNak
0698: C0 06    JC    0x069F        (0125)     jc    I2CHW_1_SetNak
069A: 26 0B 8F AND   [11],143      (0126)     and   [I2CHW_1_RsrcStatus], ~0x70                                ;clear the 0x10, 0x20 (Write status bits)
069D: 80 09    JMP   0x06A7        (0127)     jmp   I2Cs_1_ResetFlgs
                                   (0128) 
                                   (0129) I2CHW_1_SetNak:
069F: 2E 0A 04 OR    [10],4        (0130)     or    [I2CHW_1_bStatus], fI2C_NAKnextWr                          ;set the nak-next-written-byte flag.
06A2: 26 0B 8F AND   [11],143      (0131)     and   [I2CHW_1_RsrcStatus], ~0x70                                ; clear the 0x10, 0x20 (Write status bits)
06A5: 80 01    JMP   0x06A7        (0132)     jmp   I2Cs_1_ResetFlgs
                                   (0133) 
                                   (0134) I2Cs_1_ResetFlgs:
06A7: 18       POP   A             (0135)     pop A
06A8: 21 01    AND   A,1           (0136)     and A, INT_MSK3_I2C                                                ; Only enable if it was previously enabled
06AA: A0 04    JZ    0x06AF        (0137)     jz  . + 5
06AC: 43 DE 01 OR    REG[222],1    (0138)     M8C_EnableIntMask INT_MSK3, INT_MSK3_I2C
06AF: 18       POP   A             (0139)     pop A
06B0: 20       POP   X             (0140)     pop X
06B1: 70 3F    AND   F,63
                                   (0141) 	RAM_EPILOGUE RAM_USE_CLASS_4
06B3: 71 C0    OR    F,192         (0142)     RAM_EPILOGUE RAM_USE_CLASS_2
06B5: 7F       RET                 (0143)     ret
                                   (0144) 
                                   (0145) .ENDSECTION
                                   (0146) 
                                   (0147) .SECTION
                                   (0148) ;-----------------------------------------------------------------------------
                                   (0149) ;  FUNCTION NAME: I2CHW_1_InitRamRead
                                   (0150) ;
                                   (0151) ;  DESCRIPTION:
                                   (0152) ;     Initializes a data buffer pointer for the slave to use to retrieve data from,
                                   (0153) ;     and zeroes the value of a count byte for the same buffer.
                                   (0154) ;
                                   (0155) ;-----------------------------------------------------------------------------
                                   (0156) ;
                                   (0157) ;  ARGUMENTS:  [SP-5]  -- count of bytes to read
                                   (0158) ;              [SP-4]  -- Hi order part of addr to ReadBuf
                                   (0159) ;              [SP-3]  -- Low order part of the address to ReadBuf
                                   (0160) ;
                                   (0161) ;  RETURNS: none
                                   (0162) ;
                                   (0163) ;  SIDE EFFECTS:
                                   (0164) ;    The A and X registers may be modified by this or future implementations
                                   (0165) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0166) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0167) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0168) ;    functions.
                                   (0169) ;          
                                   (0170) ;    Currently only the page pointer registers listed below are modified: 
                                   (0171) ;          CUR_PP
                                   (0172) ;
                                   (0173) ;     Read Status bits are cleared
                                   (0174) ;
                                   (0175) ;  THEORY of OPERATION or PROCEDURE:
                                   (0176) ;     The C compiler will always place a 0 (the upper order byte of the address pointer) in
                                   (0177) ;     the accumulator.  X register is the low order pointer.
                                   (0178) ;
                                   (0179) 
                                   (0180)  I2CHW_1_InitRamRead:
                                   (0181) _I2CHW_1_InitRamRead:
                                   (0182) 
                                   (0183) RdCnt:     equ   -5
                                   (0184) RdBufHi:   equ   -4
                                   (0185) RdBufLo:   equ   -3
                                   (0186) 
                                   (0187)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (0188) 	RAM_PROLOGUE RAM_USE_CLASS_4
06B6: 62 D0 00 MOV   REG[208],0    (0189) 	RAM_SETPAGE_CUR >I2CHW_1_Read_Count
06B9: 10       PUSH  X             (0190)     push  X
06BA: 4F       MOV   X,SP          (0191) 	mov   X, SP
06BB: 79       DEC   X             (0192)     dec   X                                                          ;set up the pointer for correct param access
06BC: 08       PUSH  A             (0193)     push  A
06BD: 5D DE    MOV   A,REG[222]    (0194)     mov   A, reg[INT_MSK3]
06BF: 08       PUSH  A             (0195)     push  A                                                            ;preserve flags prior to disabling int
06C0: 41 DE FE AND   REG[222],254  (0196)     M8C_DisableIntMask INT_MSK3, INT_MSK3_I2C
                                   (0197) 
                                   (0198) IF SYSTEM_LARGE_MEMORY_MODEL
06C3: 52 FC    MOV   A,[X-4]       (0199)     mov   A, [X + RdBufHi]                                           ;move wrbuf addr to A
06C5: 53 0F    MOV   [15],A        (0200)     mov   [pI2CHW_1_Read_BufHI], A
                                   (0201) ENDIF
06C7: 52 FD    MOV   A,[X-3]       (0202)     mov   A, [X + RdBufLo]                                             ; move rdbuf addr to A
06C9: 53 10    MOV   [16],A        (0203)     mov   [pI2CHW_1_Read_BufLO], A
06CB: 52 FB    MOV   A,[X-5]       (0204)     mov   A, [X + RdCnt]                                               ; move RamRead_count to A
06CD: 53 11    MOV   [17],A        (0205)     mov   [I2CHW_1_Read_Count], A
06CF: 7A 11    DEC   [17]          (0206)     dec   [I2CHW_1_Read_Count]                                       ; since we decrement through zero...
06D1: 26 0B F0 AND   [11],240      (0207)     and   [I2CHW_1_RsrcStatus], ~0x0f                                ; clear the lower 4 (read status bits)
                                   (0208) 
06D4: 18       POP   A             (0209)     pop A
06D5: 21 01    AND   A,1           (0210)     and A, INT_MSK3_I2C                                                ; Only enable if it was previously enabled
06D7: A0 04    JZ    0x06DC        (0211)     jz  . + 5
06D9: 43 DE 01 OR    REG[222],1    (0212)     M8C_EnableIntMask INT_MSK3, INT_MSK3_I2C
06DC: 18       POP   A             (0213)     pop A
06DD: 20       POP   X             (0214)     pop X
06DE: 70 3F    AND   F,63
                                   (0215) 
                                   (0216)     RAM_EPILOGUE RAM_USE_CLASS_4
06E0: 71 C0    OR    F,192         (0217)     RAM_EPILOGUE RAM_USE_CLASS_2
06E2: 7F       RET                 (0218)     ret
                                   (0219) 
                                   (0220) .ENDSECTION
                                   (0221) 
                                   (0222) .SECTION
                                   (0223) ;-----------------------------------------------------------------------------
                                   (0224) ;  FUNCTION NAME: I2CHW_1_InitFlashRead
                                   (0225) ;
                                   (0226) ;  DESCRIPTION:
                                   (0227) ;     Initializes a flash data buffer pointer for the slave to use to retrieve
                                   (0228) ;     data from, and zeroes the value of a count byte for the same buffer.
                                   (0229) ;
                                   (0230) ;-----------------------------------------------------------------------------
                                   (0231) ;
                                   (0232) ;  ARGUMENTS:  [SP-6]   -- Hi order part of flash Read count
                                   (0233) ;              [SP-5]   -- Low order part of flashRead counts
                                   (0234) ;              [SP-4]   -- Hi order part of the flash buf address
                                   (0235) ;              [SP-3]   -- Lo order part of flash buf address
                                   (0236) ;
                                   (0237) ;  RETURNS:
                                   (0238) ;
                                   (0239) ;  SIDE EFFECTS:
                                   (0240) ;    The A and X registers may be modified by this or future implementations
                                   (0241) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0242) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0243) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0244) ;    functions.
                                   (0245) ;          
                                   (0246) ;    Currently only the page pointer registers listed below are modified: 
                                   (0247) ;          CUR_PP
                                   (0248) ;
                                   (0249) ;    Read Status bits are cleared
                                   (0250) ;
                                   (0251) ;  THEORY of OPERATION or PROCEDURE:
                                   (0252) ;     The C compiler will place the upper order address of the buffer in Acc.
                                   (0253) ;     X register is the low order pointer.  A user module parameter is used to conserve code
                                   (0254) ;     if flash buffers are un-needed.  The API call is left defined and capable of returning in
                                   (0255) ;     either case
                                   (0256) ;
                                   (0257)  I2CHW_1_InitFlashRead:
                                   (0258) _I2CHW_1_InitFlashRead:
                                   (0259) 
                                   (0260) FlRdCntHI:     equ   -6
                                   (0261) FlRdCntLO:     equ   -5
                                   (0262) FlBufAdrHI:    equ   -4
                                   (0263) FlBufAdrLO:    equ   -3
                                   (0264) 
                                   (0265) IF I2CHW_1_READ_FLASH
                                   (0266)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0267)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (0268)     RAM_SETPAGE_CUR >pI2CHW_1_Read_BufLO   
                                   (0269) 	push  X
                                   (0270) 	mov   X, SP
                                   (0271)     dec   X                                                            ;set up the pointer for correct param access
                                   (0272)     push  A
                                   (0273)     mov   A, reg[INT_MSK3]
                                   (0274)     push  A                                                            ;preserve flags prior to disabling int
                                   (0275)     M8C_DisableIntMask INT_MSK3, INT_MSK3_I2C
                                   (0276) 
                                   (0277)     mov   A, [X + FlBufAdrLO]                                          ; move flrdbuf LOaddr to A
                                   (0278)     mov   [pI2CHW_1_Read_BufLO], A
                                   (0279)     mov   A, [X + FlBufAdrHI]                                          ; move flrdbuf HIaddr to A
                                   (0280)     mov   [pI2CHW_1_Read_BufHI], A
                                   (0281)     mov   A, [X + FlRdCntLO]                                           ; move flrdbuf LOcount to A
                                   (0282)     mov   [I2CHW_1_Read_Count], A
                                   (0283)     mov   A, [X + FlRdCntHI]                                           ; move flrdbuf HIcount to A
                                   (0284)     mov   [I2CHW_1_Read_CountHI], A
                                   (0285) 
                                   (0286)     dec   [I2CHW_1_Read_Count]                                       ; since this will count throu zero
                                   (0287)     jnc    . + 4                                                       ; only Read_CountHI if Read_Count rolled to 0xff
                                   (0288)     dec   [I2CHW_1_Read_CountHI]
                                   (0289) 
                                   (0290)     and   [I2CHW_1_RsrcStatus], ~0x07                                ; clear the lower 3 (read status bits)
                                   (0291)     or    [I2CHW_1_RsrcStatus],I2CHW_READFLASH                       ; set the flash status bit
                                   (0292) 
                                   (0293)     pop A
                                   (0294)     and A, INT_MSK3_I2C                                                ; Only enable if it was previously enabled
                                   (0295)     jz  . + 5
                                   (0296)     M8C_EnableIntMask INT_MSK3, INT_MSK3_I2C
                                   (0297)     pop A
                                   (0298) 	pop X
                                   (0299)     RAM_EPILOGUE RAM_USE_CLASS_2
                                   (0300) 	RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0301) ENDIF
06E3: 7F       RET                 (0302)     ret
                                   (0303) 
                                   (0304) .ENDSECTION
                                   (0305) 
                                   (0306) .SECTION
                                   (0307) ;-----------------------------------------------------------------------------
                                   (0308) ;  FUNCTION NAME: I2CHW_1_bReadI2CStatus
                                   (0309) ;
                                   (0310) ;  DESCRIPTION:
                                   (0311) ;     Returns the value in the the RsrcStatus variable.
                                   (0312) ;
                                   (0313) ;-----------------------------------------------------------------------------
                                   (0314) ;
                                   (0315) ;  ARGUMENTS:
                                   (0316) ;
                                   (0317) ;  RETURNS:
                                   (0318) ;     BYTE  bI2CStatus -  status data.  Use the following defined bits
                                   (0319) ;     returned in A.
                                   (0320) ;         I2CHW_RD_NOERR:                   equ 1
                                   (0321) ;         I2CHW_RD_OVERFLOW:                equ 2
                                   (0322) ;         I2CHW_RD_INCOMPLETE:              equ 4
                                   (0323) ;         I2CHW_READFLASH:                  equ 8
                                   (0324) ;         I2CHW_WR_NOERR:                   equ 10h
                                   (0325) ;         I2CHW_WR_OVERFLOW:                equ 20h
                                   (0326) ;         I2CHW_WR_COMPLETE:                equ 40h
                                   (0327) ;         I2CHW_ISR_ACTIVE:                 equ 80h
                                   (0328) ;
                                   (0329) ;  SIDE EFFECTS:
                                   (0330) ;    The A and X registers may be modified by this or future implementations
                                   (0331) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0332) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0333) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0334) ;    functions.
                                   (0335) ;          
                                   (0336) ;    Currently only the page pointer registers listed below are modified: 
                                   (0337) ;          CUR_PP
                                   (0338) ;          
                                   (0339)  I2CHW_1_bReadI2CStatus:
                                   (0340) _I2CHW_1_bReadI2CStatus:
                                   (0341)     RAM_PROLOGUE RAM_USE_CLASS_4
06E4: 62 D0 00 MOV   REG[208],0    (0342) 	RAM_SETPAGE_CUR >I2CHW_1_RsrcStatus
06E7: 51 0B    MOV   A,[11]        (0343)     mov   A, [I2CHW_1_RsrcStatus]                                    ;return the status in A
                                   (0344)     RAM_EPILOGUE RAM_USE_CLASS_4
06E9: 7F       RET                 (0345)     ret
                                   (0346) 
                                   (0347) .ENDSECTION
                                   (0348) 
                                   (0349) .SECTION
                                   (0350) ;-----------------------------------------------------------------------------
                                   (0351) ;  FUNCTION NAME: I2CHW_1_ClrRdStatus
                                   (0352) ;
                                   (0353) ;  DESCRIPTION:
                                   (0354) ;     Clears the Status bits in the Control/Status register, doesn't alter buffer
                                   (0355) ;     addresses or counts, leaves the Flash/Ram Read bit alone too
                                   (0356) ;
                                   (0357) ;-----------------------------------------------------------------------------
                                   (0358) ;
                                   (0359) ;  ARGUMENTS: none
                                   (0360) ;
                                   (0361) ;  RETURNS: none
                                   (0362) ;
                                   (0363) ;  SIDE EFFECTS:
                                   (0364) ;    The A and X registers may be modified by this or future implementations
                                   (0365) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0366) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0367) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0368) ;    functions.
                                   (0369) ;          
                                   (0370) ;    Currently only the page pointer registers listed below are modified: 
                                   (0371) ;          CUR_PP
                                   (0372) ;          
                                   (0373)  I2CHW_1_ClrRdStatus:
                                   (0374) _I2CHW_1_ClrRdStatus:
                                   (0375)     RAM_PROLOGUE RAM_USE_CLASS_4
06EA: 62 D0 00 MOV   REG[208],0    (0376) 	RAM_SETPAGE_CUR >I2CHW_1_RsrcStatus
06ED: 26 0B F8 AND   [11],248      (0377)     and   [I2CHW_1_RsrcStatus], ~0x07                                ; clear the lower 3 (read status bits)
                                   (0378)     RAM_EPILOGUE RAM_USE_CLASS_4
06F0: 7F       RET                 (0379)     ret
                                   (0380) 
                                   (0381) .ENDSECTION
                                   (0382) 
                                   (0383) .SECTION
                                   (0384) ;-----------------------------------------------------------------------------
                                   (0385) ;  FUNCTION NAME: I2CHW_1_ClrWrStatus
                                   (0386) ;
                                   (0387) ;  DESCRIPTION:
                                   (0388) ;     Clears the Status bits in the Control/Status register, doesn't alter buffer
                                   (0389) ;     addresses or counts, leaves the Flash/Ram Read bit alone too
                                   (0390) ;
                                   (0391) ;-----------------------------------------------------------------------------
                                   (0392) ;
                                   (0393) ;  ARGUMENTS: none
                                   (0394) ;
                                   (0395) ;  RETURNS: none
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;          
                                   (0404) ;    Currently only the page pointer registers listed below are modified: 
                                   (0405) ;          CUR_PP
                                   (0406) ;          
                                   (0407)  I2CHW_1_ClrWrStatus:
                                   (0408) _I2CHW_1_ClrWrStatus:
                                   (0409)     RAM_PROLOGUE RAM_USE_CLASS_4
06F1: 62 D0 00 MOV   REG[208],0    (0410) 	RAM_SETPAGE_CUR >I2CHW_1_RsrcStatus
06F4: 26 0B 8F AND   [11],143      (0411)     and   [I2CHW_1_RsrcStatus], ~0x70                                ; clear bits 10,20 (write status bits)
                                   (0412)     RAM_EPILOGUE RAM_USE_CLASS_4
06F7: 7F       RET                 (0413)     ret

FILE: lib\counter8_1.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: Counter8_1.asm
                                   (0004) ;;   Version: 2.5, Updated on 2006/05/15 at 14:57:49
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: Counter8 User Module software implementation file
                                   (0008) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "memory.inc"
                                   (0025) include "Counter8_1.inc"
                                   (0026) 
                                   (0027) ;-----------------------------------------------
                                   (0028) ;  Global Symbols
                                   (0029) ;-----------------------------------------------
                                   (0030) export  Counter8_1_EnableInt
                                   (0031) export _Counter8_1_EnableInt
                                   (0032) export  Counter8_1_DisableInt
                                   (0033) export _Counter8_1_DisableInt
                                   (0034) export  Counter8_1_Start
                                   (0035) export _Counter8_1_Start
                                   (0036) export  Counter8_1_Stop
                                   (0037) export _Counter8_1_Stop
                                   (0038) export  Counter8_1_WritePeriod
                                   (0039) export _Counter8_1_WritePeriod
                                   (0040) export  Counter8_1_WriteCompareValue
                                   (0041) export _Counter8_1_WriteCompareValue
                                   (0042) export  Counter8_1_bReadCompareValue
                                   (0043) export _Counter8_1_bReadCompareValue
                                   (0044) export  Counter8_1_bReadCounter
                                   (0045) export _Counter8_1_bReadCounter
                                   (0046) 
                                   (0047) ; The following functions are deprecated and subject to omission in future releases
                                   (0048) ;
                                   (0049) export  bCounter8_1_ReadCompareValue  ; deprecated
                                   (0050) export _bCounter8_1_ReadCompareValue  ; deprecated
                                   (0051) export  bCounter8_1_ReadCounter       ; deprecated
                                   (0052) export _bCounter8_1_ReadCounter       ; deprecated
                                   (0053) 
                                   (0054) 
                                   (0055) AREA radyopnl_RAM (RAM,REL)
                                   (0056) 
                                   (0057) ;-----------------------------------------------
                                   (0058) ;  Constant Definitions
                                   (0059) ;-----------------------------------------------
                                   (0060) 
                                   (0061) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                   (0062) 
                                   (0063) 
                                   (0064) ;-----------------------------------------------
                                   (0065) ; Variable Allocation
                                   (0066) ;-----------------------------------------------
                                   (0067) 
                                   (0068) 
                                   (0069) AREA UserModules (ROM, REL)
                                   (0070) 
                                   (0071) .SECTION
                                   (0072) ;-----------------------------------------------------------------------------
                                   (0073) ;  FUNCTION NAME: Counter8_1_EnableInt
                                   (0074) ;
                                   (0075) ;  DESCRIPTION:
                                   (0076) ;     Enables this counter's interrupt by setting the interrupt enable mask bit
                                   (0077) ;     associated with this User Module. This function has no effect until and
                                   (0078) ;     unless the global interrupts are enabled (for example by using the
                                   (0079) ;     macro M8C_EnableGInt).
                                   (0080) ;-----------------------------------------------------------------------------
                                   (0081) ;
                                   (0082) ;  ARGUMENTS:    None.
                                   (0083) ;  RETURNS:      Nothing.
                                   (0084) ;  SIDE EFFECTS: 
                                   (0085) ;    The A and X registers may be modified by this or future implementations
                                   (0086) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0087) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0088) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0089) ;    functions.
                                   (0090) ;
                                   (0091)  Counter8_1_EnableInt:
                                   (0092) _Counter8_1_EnableInt:
                                   (0093)    RAM_PROLOGUE RAM_USE_CLASS_1
06F8: 43 E1 08 OR    REG[225],8    (0094)    Counter8_1_EnableInt_M
                                   (0095)    RAM_EPILOGUE RAM_USE_CLASS_1
06FB: 7F       RET                 (0096)    ret
                                   (0097) 
                                   (0098) .ENDSECTION
                                   (0099) 
                                   (0100) .SECTION
                                   (0101) ;-----------------------------------------------------------------------------
                                   (0102) ;  FUNCTION NAME: Counter8_1_DisableInt
                                   (0103) ;
                                   (0104) ;  DESCRIPTION:
                                   (0105) ;     Disables this counter's interrupt by clearing the interrupt enable
                                   (0106) ;     mask bit associated with this User Module.
                                   (0107) ;-----------------------------------------------------------------------------
                                   (0108) ;
                                   (0109) ;  ARGUMENTS:    None
                                   (0110) ;  RETURNS:      Nothing
                                   (0111) ;  SIDE EFFECTS: 
                                   (0112) ;    The A and X registers may be modified by this or future implementations
                                   (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0116) ;    functions.
                                   (0117) ;
                                   (0118)  Counter8_1_DisableInt:
                                   (0119) _Counter8_1_DisableInt:
                                   (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
06FC: 41 E1 F7 AND   REG[225],247  (0121)    Counter8_1_DisableInt_M
                                   (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
06FF: 7F       RET                 (0123)    ret
                                   (0124) 
                                   (0125) 
                                   (0126) .ENDSECTION
                                   (0127) 
                                   (0128) .SECTION
                                   (0129) ;-----------------------------------------------------------------------------
                                   (0130) ;  FUNCTION NAME: Counter8_1_Start
                                   (0131) ;
                                   (0132) ;  DESCRIPTION:
                                   (0133) ;     Sets the start bit in the Control register of this user module.  The
                                   (0134) ;     counter will begin counting on the next input clock as soon as the
                                   (0135) ;     enable input is asserted high.
                                   (0136) ;-----------------------------------------------------------------------------
                                   (0137) ;
                                   (0138) ;  ARGUMENTS:    None
                                   (0139) ;  RETURNS:      Nothing
                                   (0140) ;  SIDE EFFECTS: 
                                   (0141) ;    The A and X registers may be modified by this or future implementations
                                   (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0145) ;    functions.
                                   (0146) ;
                                   (0147)  Counter8_1_Start:
                                   (0148) _Counter8_1_Start:
                                   (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
0700: 43 2F 01 OR    REG[47],1     (0150)    Counter8_1_Start_M
                                   (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
0703: 7F       RET                 (0152)    ret
                                   (0153) 
                                   (0154) 
                                   (0155) .ENDSECTION
                                   (0156) 
                                   (0157) .SECTION
                                   (0158) ;-----------------------------------------------------------------------------
                                   (0159) ;  FUNCTION NAME: Counter8_1_Stop
                                   (0160) ;
                                   (0161) ;  DESCRIPTION:
                                   (0162) ;     Disables counter operation by clearing the start bit in the Control
                                   (0163) ;     register.
                                   (0164) ;-----------------------------------------------------------------------------
                                   (0165) ;
                                   (0166) ;  ARGUMENTS:    None
                                   (0167) ;  RETURNS:      Nothing
                                   (0168) ;  SIDE EFFECTS: 
                                   (0169) ;    The A and X registers may be modified by this or future implementations
                                   (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0173) ;    functions.
                                   (0174) ;
                                   (0175)  Counter8_1_Stop:
                                   (0176) _Counter8_1_Stop:
                                   (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
0704: 41 2F FE AND   REG[47],254   (0178)    Counter8_1_Stop_M
                                   (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
0707: 7F       RET                 (0180)    ret
                                   (0181) 
                                   (0182) 
                                   (0183) .ENDSECTION
                                   (0184) 
                                   (0185) .SECTION
                                   (0186) ;-----------------------------------------------------------------------------
                                   (0187) ;  FUNCTION NAME: Counter8_1_WritePeriod
                                   (0188) ;
                                   (0189) ;  DESCRIPTION:
                                   (0190) ;     Write the 8-bit period value into the Period register (DR1).
                                   (0191) ;-----------------------------------------------------------------------------
                                   (0192) ;
                                   (0193) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                   (0194) ;  RETURNS:   Nothing
                                   (0195) ;  SIDE EFFECTS:
                                   (0196) ;    If the counter user module is stopped, then this value will also be
                                   (0197) ;    latched into the Count register (DR0).
                                   (0198) ;     
                                   (0199) ;    The A and X registers may be modified by this or future implementations
                                   (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0203) ;    functions.
                                   (0204) ;
                                   (0205)  Counter8_1_WritePeriod:
                                   (0206) _Counter8_1_WritePeriod:
                                   (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
0708: 60 2D    MOV   REG[45],A     (0208)    mov   reg[Counter8_1_PERIOD_REG], A
                                   (0209)    RAM_EPILOGUE RAM_USE_CLASS_1
070A: 7F       RET                 (0210)    ret
                                   (0211) 
                                   (0212) 
                                   (0213) .ENDSECTION
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: Counter8_1_WriteCompareValue
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Writes compare value into the Compare register (DR2).
                                   (0221) ;-----------------------------------------------------------------------------
                                   (0222) ;
                                   (0223) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                   (0224) ;  RETURNS:      Nothing
                                   (0225) ;  SIDE EFFECTS: 
                                   (0226) ;    The A and X registers may be modified by this or future implementations
                                   (0227) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0228) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0229) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0230) ;    functions.
                                   (0231) ;
                                   (0232)  Counter8_1_WriteCompareValue:
                                   (0233) _Counter8_1_WriteCompareValue:
                                   (0234)    RAM_PROLOGUE RAM_USE_CLASS_1
070B: 60 2E    MOV   REG[46],A     (0235)    mov   reg[Counter8_1_COMPARE_REG], A
                                   (0236)    RAM_EPILOGUE RAM_USE_CLASS_1
070D: 7F       RET                 (0237)    ret
                                   (0238) 
                                   (0239) 
                                   (0240) .ENDSECTION
                                   (0241) 
                                   (0242) .SECTION
                                   (0243) ;-----------------------------------------------------------------------------
                                   (0244) ;  FUNCTION NAME: Counter8_1_bReadCompareValue
                                   (0245) ;
                                   (0246) ;  DESCRIPTION:
                                   (0247) ;     Reads the Compare register.
                                   (0248) ;-----------------------------------------------------------------------------
                                   (0249) ;
                                   (0250) ;  ARGUMENTS:    None
                                   (0251) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                   (0252) ;  SIDE EFFECTS: 
                                   (0253) ;    The A and X registers may be modified by this or future implementations
                                   (0254) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0255) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0256) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0257) ;    functions.
                                   (0258) ;
                                   (0259)  Counter8_1_bReadCompareValue:
                                   (0260) _Counter8_1_bReadCompareValue:
                                   (0261)  bCounter8_1_ReadCompareValue:                   ; this name deprecated
                                   (0262) _bCounter8_1_ReadCompareValue:                   ; this name deprecated
                                   (0263)    RAM_PROLOGUE RAM_USE_CLASS_1
070E: 5D 2E    MOV   A,REG[46]     (0264)    mov   A, reg[Counter8_1_COMPARE_REG]
                                   (0265)    RAM_EPILOGUE RAM_USE_CLASS_1
0710: 7F       RET                 (0266)    ret
                                   (0267) 
                                   (0268) 
                                   (0269) .ENDSECTION
                                   (0270) 
                                   (0271) .SECTION
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;  FUNCTION NAME: Counter8_1_bReadCounter
                                   (0274) ;
                                   (0275) ;  DESCRIPTION:
                                   (0276) ;     Returns the value in the Count register (DR0), preserving the value in
                                   (0277) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                   (0278) ;     from the Count to the Compare registers by holding the clock low in
                                   (0279) ;     the PSoC block.
                                   (0280) ;-----------------------------------------------------------------------------
                                   (0281) ;
                                   (0282) ;  ARGUMENTS: None
                                   (0283) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                   (0284) ;  SIDE EFFECTS:
                                   (0285) ;     1) If running, the user module is stopped momentarily and one or more
                                   (0286) ;        counts may be missed.
                                   (0287) ;     2) The A and X registers may be modified by this or future implementations
                                   (0288) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0289) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0290) ;        responsibility to perserve their values across calls to fastcall16 
                                   (0291) ;        functions.
                                   (0292) ;
                                   (0293)  Counter8_1_bReadCounter:
                                   (0294) _Counter8_1_bReadCounter:
                                   (0295)  bCounter8_1_ReadCounter:                        ; this name deprecated
                                   (0296) _bCounter8_1_ReadCounter:                        ; this name deprecated
                                   (0297) 
                                   (0298)    bOrigCompareValue:      EQU   0               ; Frame offset to temp Compare store
                                   (0299)    bOrigControlReg:        EQU   1               ; Frame offset to temp CR0     store
                                   (0300)    bOrigClockSetting:      EQU   2               ; Frame offset to temp Input   store
                                   (0301)    wCounter:               EQU   3               ; Frame offset to temp Count   store
                                   (0302)    STACK_FRAME_SIZE:       EQU   4               ; max stack frame size is 4 bytes
                                   (0303) 
                                   (0304)    RAM_PROLOGUE RAM_USE_CLASS_2
0711: 4F       MOV   X,SP          (0305)    mov   X, SP                                   ; X <- stack frame pointer
0712: 5D 2E    MOV   A,REG[46]     (0306)    mov   A, reg[Counter8_1_COMPARE_REG]          ; Save the Compare register on the stack
0714: 08       PUSH  A             (0307)    push  A                                       ;
0715: 5D 2F    MOV   A,REG[47]     (0308)    mov   A, reg[Counter8_1_CONTROL_REG]          ; Save CR0 (running or stopped state)
0717: 08       PUSH  A             (0309)    push  A                                       ;
0718: 41 2F FE AND   REG[47],254   (0310)    Counter8_1_Stop_M                             ; Disable (stop) the Counter if running
071B: 71 10    OR    F,16          (0311)    M8C_SetBank1                                  ;
071D: 5D 2D    MOV   A,REG[45]     (0312)    mov   A, reg[Counter8_1_INPUT_REG]            ; save the clock input setting
071F: 08       PUSH  A             (0313)    push  A                                       ;   on the stack (now 2 bytes) and ...
                                   (0314)                                                  ;   hold the clock low:
0720: 62 2D 00 MOV   REG[45],0     (0315)    mov   reg[Counter8_1_INPUT_REG], INPUT_REG_NULL
0723: 70 EF    AND   F,239         (0316)    M8C_SetBank0
                                   (0317)                                                  ; Extract the Count via DR2 register
0725: 5D 2C    MOV   A,REG[44]     (0318)    mov   A, reg[Counter8_1_COUNTER_REG]          ; DR2 <- DR0
0727: 5D 2E    MOV   A,REG[46]     (0319)    mov   A, reg[Counter8_1_COMPARE_REG]          ; Stash the Count on the stack
0729: 08       PUSH  A             (0320)    push  A                                       ;  -stack frame is now 3 bytes
072A: 52 00    MOV   A,[X+0]       (0321)    mov   A, [X+bOrigCompareValue]                ; Restore the Compare register
072C: 60 2E    MOV   REG[46],A     (0322)    mov   reg[Counter8_1_COMPARE_REG], A
072E: 71 10    OR    F,16          (0323)    M8C_SetBank1                                  ; Restore the counter operation:
0730: 52 02    MOV   A,[X+2]       (0324)    mov   A, [X+bOrigClockSetting]                ;   First, the clock setting...
0732: 60 2D    MOV   REG[45],A     (0325)    mov   reg[Counter8_1_INPUT_REG], A            ;
0734: 70 EF    AND   F,239         (0326)    M8C_SetBank0                                  ;   then re-enable (start) the counter
0736: 52 01    MOV   A,[X+1]       (0327)    mov   A, [X+bOrigControlReg]                  ;     if it was running when
0738: 60 2F    MOV   REG[47],A     (0328)    mov   reg[Counter8_1_CONTROL_REG], A          ;     this function was first called
073A: 18       POP   A             (0329)    pop   A                                       ; Setup the return value
073B: 38 FD    ADD   SP,253        (0330)    ADD   SP, -(STACK_FRAME_SIZE-1)               ; Zap remainder of stack frame
073D: 70 3F    AND   F,63
073F: 71 C0    OR    F,192         (0331)    RAM_EPILOGUE RAM_USE_CLASS_2
0741: 7F       RET                 (0332)    ret

FILE: lib\adcinc12_1int.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME:   ADCINC12_1INT.asm
                                   (0004) ;;  Version: 5.3, Updated on 2006/06/12 at 15:06:52
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION:
                                   (0008) ;;    Assembler source for interrupt routines the 12 bit Incremential
                                   (0009) ;;    A/D converter.
                                   (0010) ;;-----------------------------------------------------------------------------
                                   (0011) ;;  Copyright (c) Cypress MicroSystems 2002-2003. All Rights Reserved.
                                   (0012) ;;*****************************************************************************
                                   (0013) ;;*****************************************************************************
                                   (0014) 
                                   (0015) include "ADCINC12_1.inc"
                                   (0016) include "m8c.inc"
                                   (0017) include "memory.inc"
                                   (0018) 
                                   (0019) ;-----------------------------------------------
                                   (0020) ;  Global Symbols
                                   (0021) ;-----------------------------------------------
                                   (0022) export _ADCINC12_1_CNT_ISR
                                   (0023) export _ADCINC12_1_TMR_ISR
                                   (0024) export  ADCINC12_1_cTimerU
                                   (0025) export  ADCINC12_1_cCounterU
                                   (0026) export _ADCINC12_1_iIncr
                                   (0027) export  ADCINC12_1_iIncr
                                   (0028) export _ADCINC12_1_fIncr
                                   (0029) export  ADCINC12_1_fIncr
                                   (0030) export  ADCINC12_1_bIncrC
                                   (0031) 
                                   (0032) ;-----------------------------------------------
                                   (0033) ; Variable Allocation
                                   (0034) ;-----------------------------------------------
                                   (0035) AREA InterruptRAM (RAM,REL,CON)
                                   (0036)     ADCINC12_1_cTimerU:   BLK  1                 ;The Upper byte of the Timer
                                   (0037)     ADCINC12_1_cCounterU: BLK  1                 ;The Upper byte of the Counter
                                   (0038)    _ADCINC12_1_iIncr:
                                   (0039)     ADCINC12_1_iIncr:     BLK  2                 ;A/D value
                                   (0040)    _ADCINC12_1_fIncr:
                                   (0041)     ADCINC12_1_fIncr:     BLK  1                 ;Data Valid Flag
                                   (0042)     ADCINC12_1_bIncrC:    BLK  1                 ;# of times to run A/D
                                   (0043) 
                                   (0044) 
                                   (0045) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                   (0046) ;---------------------------------------------------
                                   (0047) ; Insert your custom declarations below this banner
                                   (0048) ;---------------------------------------------------
                                   (0049) 
                                   (0050) ;------------------------
                                   (0051) ; Includes
                                   (0052) ;------------------------
                                   (0053) 
                                   (0054) 	
                                   (0055) ;------------------------
                                   (0056) ;  Constant Definitions
                                   (0057) ;------------------------
                                   (0058) 
                                   (0059) 
                                   (0060) ;------------------------
                                   (0061) ; Variable Allocation
                                   (0062) ;------------------------
                                   (0063) 
                                   (0064) 
                                   (0065) ;---------------------------------------------------
                                   (0066) ; Insert your custom declarations above this banner
                                   (0067) ;---------------------------------------------------
                                   (0068) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0069) 
                                   (0070) 
                                   (0071) AREA UserModules (ROM, REL)
                                   (0072) ;-----------------------------------------------
                                   (0073) ;  EQUATES
                                   (0074) ;-----------------------------------------------
                                   (0075) LowByte:   equ 1
                                   (0076) HighByte:  equ 0
                                   (0077) 
                                   (0078) ;-----------------------------------------------------------------------------
                                   (0079) ;  FUNCTION NAME: _ADCINC12_1_CNT_ISR
                                   (0080) ;
                                   (0081) ;  DESCRIPTION:
                                   (0082) ;    Increment the upper (software) half on the counter whenever the
                                   (0083) ;    lower (hardware) half of the counter underflows.
                                   (0084) ;
                                   (0085) ;-----------------------------------------------------------------------------
                                   (0086) ;
                                   (0087) _ADCINC12_1_CNT_ISR:
0742: 76 13    INC   [19]          (0088)    inc [ADCINC12_1_cCounterU]
                                   (0089)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                   (0090)    ;---------------------------------------------------
                                   (0091)    ; Insert your custom code below this banner
                                   (0092)    ;---------------------------------------------------
                                   (0093)    ;   NOTE: interrupt service routines must preserve
                                   (0094)    ;   the values of the A and X CPU registers.
                                   (0095) 
                                   (0096)    ;---------------------------------------------------
                                   (0097)    ; Insert your custom code above this banner
                                   (0098)    ;---------------------------------------------------
                                   (0099)    ;@PSoC_UserCode_END@ (Do not change this line.)
0744: 7E       RETI                (0100)    reti
                                   (0101) 
                                   (0102) ;-----------------------------------------------------------------------------
                                   (0103) ;  FUNCTION NAME: _ADCINC12_1_TMR_ISR
                                   (0104) ;
                                   (0105) ;  DESCRIPTION:
                                   (0106) ;    This routine allows the counter to collect data for 64 timer cycles
                                   (0107) ;    This routine then holds the integrater in reset for one cycle while
                                   (0108) ;    the A/D value is calculated.
                                   (0109) ;
                                   (0110) ;-----------------------------------------------------------------------------
                                   (0111) ;
                                   (0112) _ADCINC12_1_TMR_ISR:
0745: 7A 12    DEC   [18]          (0113)    dec [ADCINC12_1_cTimerU]
                                   (0114) ;  if(upper count >0 )
0747: A0 02    JZ    0x074A        (0115)    jz  else1
0749: 7E       RETI                (0116)       reti
                                   (0117)    else1:;(upper count decremented to 0)
074A: 49 83 10 TST   REG[131],16   (0118)       tst reg[ADCINC12_1_AtoDcr3],10h
074D: A0 0F    JZ    0x075D        (0119)       jz   else2
                                   (0120) ;     if(A/D has been in reset mode)
074F: 40       NOP                 (0121)          nop                                     ; Dummy statement to keep time
                                   (0122)                                              ; between turning on and off counter
                                   (0123)                          ; the same.
0750: 62 27 05 MOV   REG[39],5     (0124)          mov reg[ADCINC12_1_CounterCR0],(ADCINC12_1_fDBLK_ENABLE|ADCINC12_1_fPULSE_WIDE)    ; Enable Counter
0753: 41 83 EF AND   REG[131],239  (0125)          and reg[ADCINC12_1_AtoDcr3],~10h        ; Enable Analog Integrator
                                   (0126) IF ADCINC12_1_NoAZ
0756: 41 82 DF AND   REG[130],223  (0127)          and reg[ADCINC12_1_AtoDcr2],~20h
                                   (0128) ENDIF
0759: 55 12 40 MOV   [18],64       (0129)          mov [ADCINC12_1_cTimerU],(1<<(ADCINC12_1_NUMBITS - 6))
                                   (0130)                                                  ; This will be the real counter value
075C: 7E       RETI                (0131)          reti
                                   (0132)       else2:;(A/D has been in integrate mode)
075D: 71 10    OR    F,16          (0133)          M8C_SetBank1
075F: 41 25 0F AND   REG[37],15    (0134)          and reg[ADCINC12_1_CounterSL], 0x0F     ; Disable input to counter
0762: 70 EF    AND   F,239         (0135)          M8C_SetBank0
                                   (0136) 
0764: 71 01    OR    F,1           (0137)          or  F,01h                               ;Enable the interrupts
                                   (0138)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0139)          ; Good place to add code to switch inputs for multiplexed input to ADC
                                   (0140)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0141)          ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                   (0142)          ;---------------------------------------------------
                                   (0143)          ; Insert your custom code below this banner
                                   (0144)          ;---------------------------------------------------
                                   (0145)          ;   NOTE: interrupt service routines must preserve
                                   (0146)          ;   the values of the A and X CPU registers.
                                   (0147) 
                                   (0148)          ;---------------------------------------------------
                                   (0149)          ; Insert your custom code above this banner
                                   (0150)          ;---------------------------------------------------
                                   (0151)          ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0152) 
                                   (0153) IF ADCINC12_1_NoAZ
0766: 43 82 20 OR    REG[130],32   (0154)          or  reg[ADCINC12_1_AtoDcr2],20h         ;Reset Integrator
                                   (0155) ENDIF
0769: 43 83 10 OR    REG[131],16   (0156)          or  reg[ADCINC12_1_AtoDcr3],10h
076C: 08       PUSH  A             (0157)          push A
076D: 5D 24    MOV   A,REG[36]     (0158)          mov A, reg[ADCINC12_1_CounterDR0]       ;read Counter
076F: 5D 26    MOV   A,REG[38]     (0159)          mov A, reg[ADCINC12_1_CounterDR2]       ;now you really read the data
                                   (0160) 
0771: 62 27 00 MOV   REG[39],0     (0161)          mov reg[ADCINC12_1_CounterCR0],00h      ;disable counter
0774: 71 10    OR    F,16          (0162)      M8C_SetBank1
0776: 43 25 40 OR    REG[37],64    (0163)          or  reg[ADCINC12_1_CounterSL],ADCINC12_1_CNTINPUT  ; Reconnect counter to comparitor
0779: 70 EF    AND   F,239         (0164)      M8C_SetBank0
                                   (0165) 
                                   (0166) 
077B: 73       CPL   A             (0167)          cpl A
077C: 3C 13 20 CMP   [19],32       (0168)          cmp [ADCINC12_1_cCounterU],(1<<(ADCINC12_1_NUMBITS - 7))
077F: B0 05    JNZ   0x0785        (0169)          jnz endif10
                                   (0170) ;        if(max positive value)
0781: 7A 13    DEC   [19]          (0171)             dec [ADCINC12_1_cCounterU]
0783: 50 FF    MOV   A,255         (0172)             mov A,ffh
                                   (0173)          endif10:
0785: 68 13    ASR   [19]          (0174)          asr [ADCINC12_1_cCounterU]              ; divide by 4
0787: 6D       RRC   A             (0175)          rrc A
0788: 68 13    ASR   [19]          (0176)          asr [ADCINC12_1_cCounterU]
078A: 6D       RRC   A             (0177)          rrc A
                                   (0178) ;
078B: 5F 14 13 MOV   [20],[19]     (0179)          mov [(ADCINC12_1_iIncr + HighByte)],[ADCINC12_1_cCounterU]
078E: 53 15    MOV   [21],A        (0180)          mov [(ADCINC12_1_iIncr + LowByte)],A
0790: 55 16 01 MOV   [22],1        (0181)          mov [ADCINC12_1_fIncr],01h              ;Set AD data flag
0793: 18       POP   A             (0182)          pop A
                                   (0183)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0184)          ; User code here for interrupt system.
                                   (0185)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0186) 
                                   (0187)          ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                   (0188)          ;---------------------------------------------------
                                   (0189)          ; Insert your custom code below this banner
                                   (0190)          ;---------------------------------------------------
                                   (0191)          ;   NOTE: interrupt service routines must preserve
                                   (0192)          ;   the values of the A and X CPU registers.
                                   (0193) 
                                   (0194)          ;---------------------------------------------------
                                   (0195)          ; Insert your custom code above this banner
                                   (0196)          ;---------------------------------------------------
                                   (0197)          ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0198) 
0794: 3C 17 00 CMP   [23],0        (0199)          cmp [ADCINC12_1_bIncrC],00h
0797: A0 17    JZ    0x07AF        (0200)          jz  endif3
                                   (0201) ;        if(ADCINC12_1_bIncrC is not zero)
0799: 7A 17    DEC   [23]          (0202)             dec [ADCINC12_1_bIncrC]
079B: B0 13    JNZ   0x07AF        (0203)             jnz endif4
                                   (0204) ;           if(ADCINC12_1_bIncrC has decremented down to zero to 0)
079D: 62 23 00 MOV   REG[35],0     (0205)                mov reg[ADCINC12_1_TimerCR0],00h      ;disable the Timer
07A0: 62 27 00 MOV   REG[39],0     (0206)                mov reg[ADCINC12_1_CounterCR0],00h    ;disable the Counter
07A3: 40       NOP                 (0207)                nop
07A4: 40       NOP                 (0208)                nop
07A5: 41 E1 FC AND   REG[225],252  (0209)                and reg[INT_MSK1],~(ADCINC12_1_TimerMask | ADCINC12_1_CounterMask)
                                   (0210)                                                            ;Disable both interrupts
                                   (0211) IF ADCINC12_1_NoAZ
07A8: 43 82 20 OR    REG[130],32   (0212)                or  reg[ADCINC12_1_AtoDcr2],20h       ;Reset Integrator
                                   (0213) ENDIF
07AB: 43 83 10 OR    REG[131],16   (0214)                or  reg[ADCINC12_1_AtoDcr3],10h
07AE: 7E       RETI                (0215)                reti
                                   (0216)             endif4:;
                                   (0217)          endif3:;
                                   (0218)       endif2:;
07AF: 55 12 01 MOV   [18],1        (0219)       mov [ADCINC12_1_cTimerU],1                     ;Set Timer for one cycle of reset
07B2: 55 13 E0 MOV   [19],224      (0220)       mov [ADCINC12_1_cCounterU],(-(1<<(ADCINC12_1_NUMBITS - 7)))  ;Set Counter hardware for easy enable
07B5: 62 25 FF MOV   REG[37],255   (0221)       mov reg[ADCINC12_1_CounterDR1],ffh
07B8: 7E       RETI                (0222)       reti

FILE: .\main.c
(0001) //----------------------------------------------------------------------------
(0002) // Radio Panel 14.May.2009
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) #include <m8c.h>
(0006) #include "PSoCAPI.h"
(0007) #include "hbheader.h"
(0008) #include "stdlib.h"
(0009) 
(0010) #define SLAVE_ADDRESS 17
(0011) 
(0012) BYTE    txBuffer[32];  
(0013) BYTE    rxBuffer[32]; 
(0014) BYTE	lastport;
(0015) BYTE 	adc_res[16] = {0}; 
(0016) BYTE	ekran_res[4] = {0};  // [0]=NAV ACT, [1]=NAV STB
(0017) BYTE	ekran_res_dummy[4] = {0};
(0018) BOOL	son = FALSE;
(0019) 
(0020) BYTE	sol_intkisim=0, sol_decisim=0, sag_intkisim=0, sag_decisim=0;
(0021) 
(0022) BYTE    status;  
(0023) BYTE *ptr;
(0024) //char *intRet;
(0025) char intRet[8];
(0026) 
(0027) WORD cnt;
(0028) WORD acnt;
(0029) WORD Timeout_d;
(0030) void  I2Oku(void), I2Yaz(void);
(0031) void Int_tostring(int val);
(0032) 
(0033) #pragma interrupt_handler Counter8_1_ISR, encoder_isr
(0034) void Counter8_1_ISR(void); void encoder_isr(void);
(0035) 
(0036) void dly(long int mS), init_environment(void);
(0037) 
(0038) void Counter8_1_ISR() {Counter8_1_DisableInt(); Counter8_1_Stop(); DELAY_CLR;}
_Counter8_1_ISR:
__text_start:
07B9: 71 C0    OR    F,192
07BB: 08       PUSH  A
07BC: 5D D0    MOV   A,REG[208]
07BE: 08       PUSH  A
07BF: 5D D3    MOV   A,REG[211]
07C1: 08       PUSH  A
07C2: 5D D4    MOV   A,REG[212]
07C4: 08       PUSH  A
07C5: 5D D5    MOV   A,REG[213]
07C7: 08       PUSH  A
07C8: 62 D0 01 MOV   REG[208],1
07CB: 51 0E    MOV   A,[__r0]
07CD: 08       PUSH  A
07CE: 51 0D    MOV   A,[__r1]
07D0: 08       PUSH  A
07D1: 51 0C    MOV   A,[__r2]
07D3: 08       PUSH  A
07D4: 51 0B    MOV   A,[__r3]
07D6: 08       PUSH  A
07D7: 51 0A    MOV   A,[__r4]
07D9: 08       PUSH  A
07DA: 51 09    MOV   A,[__r5]
07DC: 08       PUSH  A
07DD: 51 08    MOV   A,[__r6]
07DF: 08       PUSH  A
07E0: 51 07    MOV   A,[__r7]
07E2: 08       PUSH  A
07E3: 51 06    MOV   A,[__r8]
07E5: 08       PUSH  A
07E6: 51 05    MOV   A,[__r9]
07E8: 08       PUSH  A
07E9: 51 04    MOV   A,[__r10]
07EB: 08       PUSH  A
07EC: 51 03    MOV   A,[__r11]
07EE: 08       PUSH  A
07EF: 51 02    MOV   A,[__rX]
07F1: 08       PUSH  A
07F2: 51 01    MOV   A,[__rY]
07F4: 08       PUSH  A
07F5: 51 00    MOV   A,[__rZ]
07F7: 08       PUSH  A
07F8: 10       PUSH  X
07F9: 7C 06 FC LCALL 0x06FC
07FC: 7C 07 04 LCALL 0x0704
07FF: 20       POP   X
0800: 62 D0 01 MOV   REG[208],1
0803: 51 26    MOV   A,[STATUS+1]
0805: 21 FE    AND   A,254
0807: 62 D0 01 MOV   REG[208],1
080A: 53 0D    MOV   [__r1],A
080C: 62 D0 01 MOV   REG[208],1
080F: 51 25    MOV   A,[STATUS]
0811: 62 D0 01 MOV   REG[208],1
0814: 53 0E    MOV   [__r0],A
0816: 51 0D    MOV   A,[__r1]
0818: 08       PUSH  A
0819: 51 0E    MOV   A,[__r0]
081B: 62 D0 01 MOV   REG[208],1
081E: 53 25    MOV   [STATUS],A
0820: 18       POP   A
0821: 53 26    MOV   [STATUS+1],A
0823: 62 D0 01 MOV   REG[208],1
0826: 18       POP   A
0827: 53 00    MOV   [__rZ],A
0829: 18       POP   A
082A: 53 01    MOV   [__rY],A
082C: 18       POP   A
082D: 53 02    MOV   [__rX],A
082F: 18       POP   A
0830: 53 03    MOV   [__r11],A
0832: 18       POP   A
0833: 53 04    MOV   [__r10],A
0835: 18       POP   A
0836: 53 05    MOV   [__r9],A
0838: 18       POP   A
0839: 53 06    MOV   [__r8],A
083B: 18       POP   A
083C: 53 07    MOV   [__r7],A
083E: 18       POP   A
083F: 53 08    MOV   [__r6],A
0841: 18       POP   A
0842: 53 09    MOV   [__r5],A
0844: 18       POP   A
0845: 53 0A    MOV   [__r4],A
0847: 18       POP   A
0848: 53 0B    MOV   [__r3],A
084A: 18       POP   A
084B: 53 0C    MOV   [__r2],A
084D: 18       POP   A
084E: 53 0D    MOV   [__r1],A
0850: 18       POP   A
0851: 53 0E    MOV   [__r0],A
0853: 18       POP   A
0854: 60 D5    MOV   REG[213],A
0856: 18       POP   A
0857: 60 D4    MOV   REG[212],A
0859: 18       POP   A
085A: 60 D3    MOV   REG[211],A
085C: 18       POP   A
085D: 60 D0    MOV   REG[208],A
085F: 18       POP   A
0860: 7E       RETI  
(0039) 
(0040) void encoder_isr(void){
(0041) }
_encoder_isr:
0861: 7E       RETI  
(0042) 		
(0043) void init_environment()
(0044) {  	PRT1DR |= 0xA0;		//release et pinleri
_init_environment:
0862: 43 04 A0 OR    REG[4],160
(0045) 	I2CHW_1_Start(); I2CHW_1_EnableSlave(); I2CHW_1_EnableInt();
0865: 10       PUSH  X
0866: 7C 05 40 LCALL 0x0540
0869: 7C 05 51 LCALL 0x0551
086C: 7C 05 41 LCALL 0x0541
(0046) 	I2CHW_1_InitRamRead(txBuffer,32);
086F: 50 20    MOV   A,32
0871: 08       PUSH  A
0872: 50 00    MOV   A,0
0874: 08       PUSH  A
0875: 50 B8    MOV   A,184
0877: 08       PUSH  A
0878: 7C 06 B6 LCALL 0x06B6
087B: 38 FD    ADD   SP,253
(0047)     I2CHW_1_InitWrite(rxBuffer,32);
087D: 50 20    MOV   A,32
087F: 08       PUSH  A
0880: 50 00    MOV   A,0
0882: 08       PUSH  A
0883: 50 98    MOV   A,152
0885: 08       PUSH  A
0886: 7C 06 78 LCALL 0x0678
0889: 38 FD    ADD   SP,253
088B: 20       POP   X
(0048) 	M8C_EnableGInt;	M8C_EnableIntMask (INT_MSK0, INT_MSK0_GPIO); LED7SEG_1_Start();
088C: 71 01    OR    F,1
088E: 43 E0 20 OR    REG[224],32
0891: 7C 03 D7 LCALL 0x03D7
(0049)     
(0050)     ekran_res[0]=1; lastport=0;
0894: 62 D0 01 MOV   REG[208],1
0897: 55 21 01 MOV   [ekran_res],1
089A: 62 D0 01 MOV   REG[208],1
089D: 55 34 00 MOV   [lastport],0
(0051)     ekran_res[1]=1;
08A0: 62 D0 01 MOV   REG[208],1
08A3: 55 22 01 MOV   [ekran_res+1],1
(0052)     ekran_res[2]=1;
08A6: 55 23 01 MOV   [ekran_res+2],1
(0053)     ekran_res[3]=1;
08A9: 55 24 01 MOV   [ekran_res+3],1
(0054)     }
08AC: 7F       RET   
(0055) 
(0056) void init_delay_counter(long int mSn, long int DC)
(0057) {   Counter8_1_WritePeriod(mSn); Counter8_1_WriteCompareValue(DC); Counter8_1_EnableInt();DELAY_SET; Counter8_1_Start();}
_init_delay_counter:
  DC                   --> X-11
  mSn                  --> X-7
08AD: 10       PUSH  X
08AE: 4F       MOV   X,SP
08AF: 62 D0 01 MOV   REG[208],1
08B2: 52 FC    MOV   A,[X-4]
08B4: 10       PUSH  X
08B5: 7C 07 08 LCALL 0x0708
08B8: 20       POP   X
08B9: 62 D0 01 MOV   REG[208],1
08BC: 52 F8    MOV   A,[X-8]
08BE: 10       PUSH  X
08BF: 7C 07 0B LCALL 0x070B
08C2: 7C 06 F8 LCALL 0x06F8
08C5: 20       POP   X
08C6: 62 D0 01 MOV   REG[208],1
08C9: 2E 26 01 OR    [STATUS+1],1
08CC: 10       PUSH  X
08CD: 7C 07 00 LCALL 0x0700
08D0: 20       POP   X
08D1: 20       POP   X
08D2: 7F       RET   
(0058) /* ---------------------------------------------------------------------- */
(0059) 
(0060) void main()
(0061) {
_main:
  dummy1               --> X+0
08D3: 10       PUSH  X
08D4: 4F       MOV   X,SP
08D5: 38 03    ADD   SP,3
(0062) // NAV LIMITS   = 108.00-117.95 (2048--6037)
(0063) // COMM LIMITS  = 118.00-136.97 (6144--13975)
(0064) // XPNDR LIMITS = 0000-7777		(Octal system)
(0065) // ADF LIMITS   = 0100.0-1799.9
(0066) 
(0067) 	init_environment();
08D7: 9F 89    CALL  _init_environment
(0068) 	LED7SEG_1_DP(1, 2); 	LED7SEG_1_DP(1, 6);
08D9: 10       PUSH  X
08DA: 57 02    MOV   X,2
08DC: 50 01    MOV   A,1
08DE: 7C 04 B0 LCALL 0x04B0
08E1: 57 06    MOV   X,6
08E3: 50 01    MOV   A,1
08E5: 7C 04 B0 LCALL 0x04B0
08E8: 20       POP   X
(0069)  	son=FALSE;
08E9: 62 D0 01 MOV   REG[208],1
08EC: 55 30 00 MOV   [son],0
08EF: 83 4A    JMP   0x0C3A
(0070)  	
(0071)  	while(1)  {
(0072) 			//txBuffer[0]=
(0073) 			BYTE dummy1;
(0074) 
(0075) 			I2Oku();	
08F1: 93 D4    CALL  _I2Oku
(0076) 
(0077) 			//sayiyaz();
(0078) 			dummy1 = PRT3DR^lastport;	//durumu degisen pin varmi?
08F3: 5D 0C    MOV   A,REG[12]
08F5: 62 D0 01 MOV   REG[208],1
08F8: 53 0E    MOV   [__r0],A
08FA: 62 D0 01 MOV   REG[208],1
08FD: 51 34    MOV   A,[lastport]
08FF: 62 D0 01 MOV   REG[208],1
0902: 34 0E    XOR   [__r0],A
0904: 51 0E    MOV   A,[__r0]
0906: 54 00    MOV   [X+0],A
(0079) 
(0080) 			if (dummy1 & BSET_0) {		//0. pinin durumu degismis
0908: 48 00 01 TST   [X+0],1
090B: A0 82    JZ    0x098E
(0081) 				lastport=PRT3DR;
090D: 5D 0C    MOV   A,REG[12]
090F: 62 D0 01 MOV   REG[208],1
0912: 53 34    MOV   [lastport],A
(0082) 				switch  (PRT3DR & 0b00000011) {	//bu encoder hangi yone donuyor?
0914: 5D 0C    MOV   A,REG[12]
0916: 62 D0 01 MOV   REG[208],1
0919: 21 03    AND   A,3
091B: 54 02    MOV   [X+2],A
091D: 56 01 00 MOV   [X+1],0
0920: 3D 01 00 CMP   [X+1],0
0923: B0 06    JNZ   0x092A
0925: 3D 02 01 CMP   [X+2],1
0928: A0 0D    JZ    0x0936
092A: 3D 01 00 CMP   [X+1],0
092D: B0 06    JNZ   0x0934
092F: 3D 02 03 CMP   [X+2],3
0932: A0 30    JZ    0x0963
0934: 80 59    JMP   0x098E
(0083) //						case 0: if (PRT2DR & BSET_7) {
(0084) //									if (ekran_res[2]==20) {ekran_res[2]=1;} else {ekran_res[2]++; }}
(0085) //								else {
(0086) //									if (ekran_res[0]==10) {ekran_res[0]=1;} else {ekran_res[0]++; }}
(0087) //								break;
(0088) //						
(0089) 						case 1: if (PRT7DR & BSET_7) {
0936: 49 1C 80 TST   REG[28],128
0939: A0 15    JZ    0x094F
(0090) 									if (ekran_res[2]==1) {ekran_res[2]=20;} else {ekran_res[2]--; }}
093B: 62 D0 01 MOV   REG[208],1
093E: 3C 23 01 CMP   [ekran_res+2],1
0941: B0 06    JNZ   0x0948
0943: 55 23 14 MOV   [ekran_res+2],20
0946: 80 47    JMP   0x098E
0948: 62 D0 01 MOV   REG[208],1
094B: 7A 23    DEC   [ekran_res+2]
094D: 80 40    JMP   0x098E
(0091) 								else {
(0092) 									if (ekran_res[0]==1) {ekran_res[0]=10;} else {ekran_res[0]--; }}
094F: 62 D0 01 MOV   REG[208],1
0952: 3C 21 01 CMP   [ekran_res],1
0955: B0 06    JNZ   0x095C
0957: 55 21 0A MOV   [ekran_res],10
095A: 80 33    JMP   0x098E
095C: 62 D0 01 MOV   REG[208],1
095F: 7A 21    DEC   [ekran_res]
(0093) 								break;
0961: 80 2C    JMP   0x098E
(0094) 						
(0095) //						case 2: if (PRT2DR & BSET_7) {
(0096) //									if (ekran_res[2]==1) {ekran_res[2]=20;} else {ekran_res[2]--; }}
(0097) //								else {
(0098) //									if (ekran_res[0]==1) {ekran_res[0]=10;} else {ekran_res[0]--; }}
(0099) //								break;
(0100) 						
(0101) 						case 3: if (PRT7DR & BSET_7) {
0963: 49 1C 80 TST   REG[28],128
0966: A0 15    JZ    0x097C
(0102) 									if (ekran_res[2]==20) {ekran_res[2]=1;} else {ekran_res[2]++; }}
0968: 62 D0 01 MOV   REG[208],1
096B: 3C 23 14 CMP   [ekran_res+2],20
096E: B0 06    JNZ   0x0975
0970: 55 23 01 MOV   [ekran_res+2],1
0973: 80 1A    JMP   0x098E
0975: 62 D0 01 MOV   REG[208],1
0978: 76 23    INC   [ekran_res+2]
097A: 80 13    JMP   0x098E
(0103) 								else {
(0104) 									if (ekran_res[0]==10) {ekran_res[0]=1;} else {ekran_res[0]++; }}
097C: 62 D0 01 MOV   REG[208],1
097F: 3C 21 0A CMP   [ekran_res],10
0982: B0 06    JNZ   0x0989
0984: 55 21 01 MOV   [ekran_res],1
0987: 80 06    JMP   0x098E
0989: 62 D0 01 MOV   REG[208],1
098C: 76 21    INC   [ekran_res]
(0105) 								break;
(0106) 						
(0107) 						}}
(0108) 			if (dummy1 & BSET_2) {		//2. pinin durumu degismis
098E: 48 00 04 TST   [X+0],4
0991: A0 8A    JZ    0x0A1C
(0109) 				lastport=PRT3DR;
0993: 5D 0C    MOV   A,REG[12]
0995: 62 D0 01 MOV   REG[208],1
0998: 53 34    MOV   [lastport],A
(0110) 				switch  (PRT3DR & 0b00001100) {	//bu encoder hangi yone donuyor?
099A: 5D 0C    MOV   A,REG[12]
099C: 62 D0 01 MOV   REG[208],1
099F: 21 0C    AND   A,12
09A1: 54 02    MOV   [X+2],A
09A3: 56 01 00 MOV   [X+1],0
09A6: 52 02    MOV   A,[X+2]
09A8: 11 04    SUB   A,4
09AA: 53 01    MOV   [__rY],A
09AC: 52 01    MOV   A,[X+1]
09AE: 31 80    XOR   A,128
09B0: 19 80    SBB   A,128
09B2: C0 69    JC    0x0A1C
09B4: 2A 01    OR    A,[__rY]
09B6: A0 0D    JZ    0x09C4
09B8: 3D 01 00 CMP   [X+1],0
09BB: B0 06    JNZ   0x09C2
09BD: 3D 02 0C CMP   [X+2],12
09C0: A0 30    JZ    0x09F1
09C2: 80 59    JMP   0x0A1C
(0111) //						case 0: if (PRT2DR & BSET_6) {
(0112) //									if (ekran_res[3]==20) {ekran_res[3]=1;} else {ekran_res[3]++; }}
(0113) //								else {
(0114) //									if (ekran_res[1]==10) {ekran_res[1]=1;} else {ekran_res[1]++; }}
(0115) //								break;
(0116) //						
(0117) 						case 4: if (PRT7DR & BSET_0) {
09C4: 49 1C 01 TST   REG[28],1
09C7: A0 15    JZ    0x09DD
(0118) 									if (ekran_res[3]==1) {ekran_res[3]=20;} else {ekran_res[3]--; }}
09C9: 62 D0 01 MOV   REG[208],1
09CC: 3C 24 01 CMP   [ekran_res+3],1
09CF: B0 06    JNZ   0x09D6
09D1: 55 24 14 MOV   [ekran_res+3],20
09D4: 80 47    JMP   0x0A1C
09D6: 62 D0 01 MOV   REG[208],1
09D9: 7A 24    DEC   [ekran_res+3]
09DB: 80 40    JMP   0x0A1C
(0119) 								else {
(0120) 									if (ekran_res[1]==1) {ekran_res[1]=10;} else {ekran_res[1]--; }}
09DD: 62 D0 01 MOV   REG[208],1
09E0: 3C 22 01 CMP   [ekran_res+1],1
09E3: B0 06    JNZ   0x09EA
09E5: 55 22 0A MOV   [ekran_res+1],10
09E8: 80 33    JMP   0x0A1C
09EA: 62 D0 01 MOV   REG[208],1
09ED: 7A 22    DEC   [ekran_res+1]
(0121) 								break;
09EF: 80 2C    JMP   0x0A1C
(0122) 						
(0123) //						case 8: if (PRT2DR & BSET_6) {
(0124) //									if (ekran_res[3]==1) {ekran_res[3]=20;} else {ekran_res[3]--; }}
(0125) //								else {
(0126) //									if (ekran_res[1]==1) {ekran_res[1]=10;} else {ekran_res[1]--; }}
(0127) //								break;
(0128) 						
(0129) 						case 12: if (PRT7DR & BSET_0) {
09F1: 49 1C 01 TST   REG[28],1
09F4: A0 15    JZ    0x0A0A
(0130) 									if (ekran_res[3]==20) {ekran_res[3]=1;} else {ekran_res[3]++; }}
09F6: 62 D0 01 MOV   REG[208],1
09F9: 3C 24 14 CMP   [ekran_res+3],20
09FC: B0 06    JNZ   0x0A03
09FE: 55 24 01 MOV   [ekran_res+3],1
0A01: 80 1A    JMP   0x0A1C
0A03: 62 D0 01 MOV   REG[208],1
0A06: 76 24    INC   [ekran_res+3]
0A08: 80 13    JMP   0x0A1C
(0131) 								else {
(0132) 									if (ekran_res[1]==10) {ekran_res[1]=1;} else {ekran_res[1]++; }}
0A0A: 62 D0 01 MOV   REG[208],1
0A0D: 3C 22 0A CMP   [ekran_res+1],10
0A10: B0 06    JNZ   0x0A17
0A12: 55 22 01 MOV   [ekran_res+1],1
0A15: 80 06    JMP   0x0A1C
0A17: 62 D0 01 MOV   REG[208],1
0A1A: 76 22    INC   [ekran_res+1]
(0133) 								break;
(0134) 						
(0135) 						}}
(0136) 
(0137) 			if (PRT4DR & BSET_1) {
0A1C: 49 10 02 TST   REG[16],2
0A1F: A0 46    JZ    0x0A66
(0138) 				if (son) {	}	else {
0A21: 62 D0 01 MOV   REG[208],1
0A24: 3C 30 00 CMP   [son],0
0A27: A0 03    JZ    0x0A2B
0A29: 80 42    JMP   0x0A6C
(0139) 					ekran_res_dummy[0] = ekran_res[0]; 
0A2B: 62 D0 01 MOV   REG[208],1
0A2E: 51 21    MOV   A,[ekran_res]
0A30: 62 D0 00 MOV   REG[208],0
0A33: 53 FC    MOV   [ekran_res_dummy],A
(0140) 					//ekran_res_dummy[1] = ekran_res[1]; 
(0141) 					ekran_res_dummy[2] = ekran_res[2]; 
0A35: 62 D0 01 MOV   REG[208],1
0A38: 51 23    MOV   A,[ekran_res+2]
0A3A: 62 D0 00 MOV   REG[208],0
0A3D: 53 FE    MOV   [ekran_res_dummy+2],A
(0142) 					//ekran_res_dummy[3] = ekran_res[3]; 
(0143) 					ekran_res[0] = ekran_res[1];
0A3F: 62 D0 01 MOV   REG[208],1
0A42: 51 22    MOV   A,[ekran_res+1]
0A44: 53 21    MOV   [ekran_res],A
(0144) 					ekran_res[1] = ekran_res_dummy[0];
0A46: 62 D0 00 MOV   REG[208],0
0A49: 51 FC    MOV   A,[ekran_res_dummy]
0A4B: 62 D0 01 MOV   REG[208],1
0A4E: 53 22    MOV   [ekran_res+1],A
(0145) 					ekran_res[2] = ekran_res[3];
0A50: 51 24    MOV   A,[ekran_res+3]
0A52: 53 23    MOV   [ekran_res+2],A
(0146) 					ekran_res[3] = ekran_res_dummy[2];
0A54: 62 D0 00 MOV   REG[208],0
0A57: 51 FE    MOV   A,[ekran_res_dummy+2]
0A59: 62 D0 01 MOV   REG[208],1
0A5C: 53 24    MOV   [ekran_res+3],A
(0147) 					son = TRUE;
0A5E: 62 D0 01 MOV   REG[208],1
0A61: 55 30 01 MOV   [son],1
(0148) 				}}	
0A64: 80 07    JMP   0x0A6C
(0149) 			else { son = FALSE; }
0A66: 62 D0 01 MOV   REG[208],1
0A69: 55 30 00 MOV   [son],0
(0150) 			
(0151) //COMM iin gelcek sayilar 118.00-136.97
(0152) 			txBuffer[0]=ekran_res[0];	//sol asil hane
0A6C: 62 D0 01 MOV   REG[208],1
0A6F: 51 21    MOV   A,[ekran_res]
0A71: 62 D0 00 MOV   REG[208],0
0A74: 53 B8    MOV   [txBuffer],A
(0153) 			txBuffer[2]=ekran_res[1];	//sag asil hane
0A76: 62 D0 01 MOV   REG[208],1
0A79: 51 22    MOV   A,[ekran_res+1]
0A7B: 62 D0 00 MOV   REG[208],0
0A7E: 53 BA    MOV   [txBuffer+2],A
(0154) 			txBuffer[1]=ekran_res[2];	//sol decimal hane
0A80: 62 D0 01 MOV   REG[208],1
0A83: 51 23    MOV   A,[ekran_res+2]
0A85: 62 D0 00 MOV   REG[208],0
0A88: 53 B9    MOV   [txBuffer+1],A
(0155) 			txBuffer[3]=ekran_res[3];	//sag decimal hane
0A8A: 62 D0 01 MOV   REG[208],1
0A8D: 51 24    MOV   A,[ekran_res+3]
0A8F: 62 D0 00 MOV   REG[208],0
0A92: 53 BB    MOV   [txBuffer+3],A
(0156) 			
(0157) 						
(0158) 			sol_intkisim=NAV_INT[ekran_res[0]-1];
0A94: 62 D0 01 MOV   REG[208],1
0A97: 51 21    MOV   A,[ekran_res]
0A99: 62 D0 01 MOV   REG[208],1
0A9C: 53 0D    MOV   [__r1],A
0A9E: 55 0E 00 MOV   [__r0],0
0AA1: 06 0D 0E ADD   [__r1],14
0AA4: 0E 0E 01 ADC   [__r0],1
0AA7: 51 0E    MOV   A,[__r0]
0AA9: 60 D4    MOV   REG[212],A
0AAB: 3E 0D    MVI   A,[__r1]
0AAD: 62 D0 01 MOV   REG[208],1
0AB0: 53 31    MOV   [sol_intkisim],A
(0159) 			sol_decisim=NAV_DEC[ekran_res[2]-1];
0AB2: 62 D0 01 MOV   REG[208],1
0AB5: 51 23    MOV   A,[ekran_res+2]
0AB7: 62 D0 01 MOV   REG[208],1
0ABA: 53 0D    MOV   [__r1],A
0ABC: 55 0E 00 MOV   [__r0],0
0ABF: 06 0D D7 ADD   [__r1],215
0AC2: 0E 0E 00 ADC   [__r0],0
0AC5: 51 0E    MOV   A,[__r0]
0AC7: 60 D4    MOV   REG[212],A
0AC9: 3E 0D    MVI   A,[__r1]
0ACB: 62 D0 01 MOV   REG[208],1
0ACE: 53 32    MOV   [sol_decisim],A
(0160) 			sag_intkisim=NAV_INT[ekran_res[1]-1];
0AD0: 62 D0 01 MOV   REG[208],1
0AD3: 51 22    MOV   A,[ekran_res+1]
0AD5: 62 D0 01 MOV   REG[208],1
0AD8: 53 0D    MOV   [__r1],A
0ADA: 55 0E 00 MOV   [__r0],0
0ADD: 06 0D 0E ADD   [__r1],14
0AE0: 0E 0E 01 ADC   [__r0],1
0AE3: 51 0E    MOV   A,[__r0]
0AE5: 60 D4    MOV   REG[212],A
0AE7: 3E 0D    MVI   A,[__r1]
0AE9: 62 D0 01 MOV   REG[208],1
0AEC: 53 33    MOV   [sag_intkisim],A
(0161) 			sag_decisim=NAV_DEC[ekran_res[3]-1];
0AEE: 62 D0 01 MOV   REG[208],1
0AF1: 51 24    MOV   A,[ekran_res+3]
0AF3: 62 D0 01 MOV   REG[208],1
0AF6: 53 0D    MOV   [__r1],A
0AF8: 55 0E 00 MOV   [__r0],0
0AFB: 06 0D D7 ADD   [__r1],215
0AFE: 0E 0E 00 ADC   [__r0],0
0B01: 51 0E    MOV   A,[__r0]
0B03: 60 D4    MOV   REG[212],A
0B05: 3E 0D    MVI   A,[__r1]
0B07: 62 D0 01 MOV   REG[208],1
0B0A: 53 2F    MOV   [sag_decisim],A
(0162) 			
(0163) 			//LED7SEG_1_DispInt(sol_intkisim, 1, 2); 
(0164) 			if (sol_intkisim<10) {LED7SEG_1_PutPattern(63,1); LED7SEG_1_DispInt(sol_intkisim, 2, 1); } else {LED7SEG_1_DispInt(sol_intkisim, 1, 2);}
0B0C: 62 D0 01 MOV   REG[208],1
0B0F: 3C 31 0A CMP   [sol_intkisim],10
0B12: D0 27    JNC   0x0B3A
0B14: 10       PUSH  X
0B15: 57 01    MOV   X,1
0B17: 50 3F    MOV   A,63
0B19: 7C 04 9D LCALL 0x049D
0B1C: 50 01    MOV   A,1
0B1E: 08       PUSH  A
0B1F: 50 02    MOV   A,2
0B21: 08       PUSH  A
0B22: 62 D0 01 MOV   REG[208],1
0B25: 51 31    MOV   A,[sol_intkisim]
0B27: 62 D0 01 MOV   REG[208],1
0B2A: 53 0D    MOV   [__r1],A
0B2C: 50 00    MOV   A,0
0B2E: 08       PUSH  A
0B2F: 51 0D    MOV   A,[__r1]
0B31: 08       PUSH  A
0B32: 7C 04 CD LCALL 0x04CD
0B35: 38 FC    ADD   SP,252
0B37: 20       POP   X
0B38: 80 1E    JMP   0x0B57
0B3A: 10       PUSH  X
0B3B: 50 02    MOV   A,2
0B3D: 08       PUSH  A
0B3E: 50 01    MOV   A,1
0B40: 08       PUSH  A
0B41: 62 D0 01 MOV   REG[208],1
0B44: 51 31    MOV   A,[sol_intkisim]
0B46: 62 D0 01 MOV   REG[208],1
0B49: 53 0D    MOV   [__r1],A
0B4B: 50 00    MOV   A,0
0B4D: 08       PUSH  A
0B4E: 51 0D    MOV   A,[__r1]
0B50: 08       PUSH  A
0B51: 7C 04 CD LCALL 0x04CD
0B54: 38 FC    ADD   SP,252
0B56: 20       POP   X
(0165) 			if (sol_decisim<10) {LED7SEG_1_PutPattern(63,3); LED7SEG_1_DispInt(sol_decisim, 4, 1); } else {LED7SEG_1_DispInt(sol_decisim, 3, 2);}
0B57: 62 D0 01 MOV   REG[208],1
0B5A: 3C 32 0A CMP   [sol_decisim],10
0B5D: D0 27    JNC   0x0B85
0B5F: 10       PUSH  X
0B60: 57 03    MOV   X,3
0B62: 50 3F    MOV   A,63
0B64: 7C 04 9D LCALL 0x049D
0B67: 50 01    MOV   A,1
0B69: 08       PUSH  A
0B6A: 50 04    MOV   A,4
0B6C: 08       PUSH  A
0B6D: 62 D0 01 MOV   REG[208],1
0B70: 51 32    MOV   A,[sol_decisim]
0B72: 62 D0 01 MOV   REG[208],1
0B75: 53 0D    MOV   [__r1],A
0B77: 50 00    MOV   A,0
0B79: 08       PUSH  A
0B7A: 51 0D    MOV   A,[__r1]
0B7C: 08       PUSH  A
0B7D: 7C 04 CD LCALL 0x04CD
0B80: 38 FC    ADD   SP,252
0B82: 20       POP   X
0B83: 80 1E    JMP   0x0BA2
0B85: 10       PUSH  X
0B86: 50 02    MOV   A,2
0B88: 08       PUSH  A
0B89: 50 03    MOV   A,3
0B8B: 08       PUSH  A
0B8C: 62 D0 01 MOV   REG[208],1
0B8F: 51 32    MOV   A,[sol_decisim]
0B91: 62 D0 01 MOV   REG[208],1
0B94: 53 0D    MOV   [__r1],A
0B96: 50 00    MOV   A,0
0B98: 08       PUSH  A
0B99: 51 0D    MOV   A,[__r1]
0B9B: 08       PUSH  A
0B9C: 7C 04 CD LCALL 0x04CD
0B9F: 38 FC    ADD   SP,252
0BA1: 20       POP   X
(0166) 
(0167) 			//LED7SEG_1_DispInt(sag_intkisim, 5, 2); 
(0168) 			if (sag_intkisim<10) {LED7SEG_1_PutPattern(63,5); LED7SEG_1_DispInt(sag_intkisim, 6, 1); } else {LED7SEG_1_DispInt(sag_intkisim, 5, 2);}
0BA2: 62 D0 01 MOV   REG[208],1
0BA5: 3C 33 0A CMP   [sag_intkisim],10
0BA8: D0 27    JNC   0x0BD0
0BAA: 10       PUSH  X
0BAB: 57 05    MOV   X,5
0BAD: 50 3F    MOV   A,63
0BAF: 7C 04 9D LCALL 0x049D
0BB2: 50 01    MOV   A,1
0BB4: 08       PUSH  A
0BB5: 50 06    MOV   A,6
0BB7: 08       PUSH  A
0BB8: 62 D0 01 MOV   REG[208],1
0BBB: 51 33    MOV   A,[sag_intkisim]
0BBD: 62 D0 01 MOV   REG[208],1
0BC0: 53 0D    MOV   [__r1],A
0BC2: 50 00    MOV   A,0
0BC4: 08       PUSH  A
0BC5: 51 0D    MOV   A,[__r1]
0BC7: 08       PUSH  A
0BC8: 7C 04 CD LCALL 0x04CD
0BCB: 38 FC    ADD   SP,252
0BCD: 20       POP   X
0BCE: 80 1E    JMP   0x0BED
0BD0: 10       PUSH  X
0BD1: 50 02    MOV   A,2
0BD3: 08       PUSH  A
0BD4: 50 05    MOV   A,5
0BD6: 08       PUSH  A
0BD7: 62 D0 01 MOV   REG[208],1
0BDA: 51 33    MOV   A,[sag_intkisim]
0BDC: 62 D0 01 MOV   REG[208],1
0BDF: 53 0D    MOV   [__r1],A
0BE1: 50 00    MOV   A,0
0BE3: 08       PUSH  A
0BE4: 51 0D    MOV   A,[__r1]
0BE6: 08       PUSH  A
0BE7: 7C 04 CD LCALL 0x04CD
0BEA: 38 FC    ADD   SP,252
0BEC: 20       POP   X
(0169) 			if (sag_decisim<10) {LED7SEG_1_PutPattern(63,7); LED7SEG_1_DispInt(sag_decisim, 8, 1); } else {LED7SEG_1_DispInt(sag_decisim, 7, 2);}
0BED: 62 D0 01 MOV   REG[208],1
0BF0: 3C 2F 0A CMP   [sag_decisim],10
0BF3: D0 27    JNC   0x0C1B
0BF5: 10       PUSH  X
0BF6: 57 07    MOV   X,7
0BF8: 50 3F    MOV   A,63
0BFA: 7C 04 9D LCALL 0x049D
0BFD: 50 01    MOV   A,1
0BFF: 08       PUSH  A
0C00: 50 08    MOV   A,8
0C02: 08       PUSH  A
0C03: 62 D0 01 MOV   REG[208],1
0C06: 51 2F    MOV   A,[sag_decisim]
0C08: 62 D0 01 MOV   REG[208],1
0C0B: 53 0D    MOV   [__r1],A
0C0D: 50 00    MOV   A,0
0C0F: 08       PUSH  A
0C10: 51 0D    MOV   A,[__r1]
0C12: 08       PUSH  A
0C13: 7C 04 CD LCALL 0x04CD
0C16: 38 FC    ADD   SP,252
0C18: 20       POP   X
0C19: 80 1E    JMP   0x0C38
0C1B: 10       PUSH  X
0C1C: 50 02    MOV   A,2
0C1E: 08       PUSH  A
0C1F: 50 07    MOV   A,7
0C21: 08       PUSH  A
0C22: 62 D0 01 MOV   REG[208],1
0C25: 51 2F    MOV   A,[sag_decisim]
0C27: 62 D0 01 MOV   REG[208],1
0C2A: 53 0D    MOV   [__r1],A
0C2C: 50 00    MOV   A,0
0C2E: 08       PUSH  A
0C2F: 51 0D    MOV   A,[__r1]
0C31: 08       PUSH  A
0C32: 7C 04 CD LCALL 0x04CD
0C35: 38 FC    ADD   SP,252
0C37: 20       POP   X
(0170) 						
(0171) 			I2Yaz();
0C38: 90 6A    CALL  _I2Yaz
0C3A: 8C B6    JMP   0x08F1
(0172) 
(0173) 	
(0174) }//while kapa	
(0175) }//main kapa
0C3C: 38 FD    ADD   SP,253
0C3E: 20       POP   X
0C3F: 8F FF    JMP   0x0C3F
(0176) 
(0177) void dly(long int mS){init_delay_counter(mS,mS/2); while (DELAY_INVOKE);{}}
_dly:
  mS                   --> X-7
0C41: 10       PUSH  X
0C42: 4F       MOV   X,SP
0C43: 62 D0 01 MOV   REG[208],1
0C46: 50 00    MOV   A,0
0C48: 08       PUSH  A
0C49: 08       PUSH  A
0C4A: 08       PUSH  A
0C4B: 50 02    MOV   A,2
0C4D: 08       PUSH  A
0C4E: 52 F9    MOV   A,[X-7]
0C50: 08       PUSH  A
0C51: 52 FA    MOV   A,[X-6]
0C53: 08       PUSH  A
0C54: 52 FB    MOV   A,[X-5]
0C56: 08       PUSH  A
0C57: 52 FC    MOV   A,[X-4]
0C59: 08       PUSH  A
0C5A: 7C 0C EA LCALL __divmod_32X32_32
0C5D: 18       POP   A
0C5E: 53 0B    MOV   [__r3],A
0C60: 18       POP   A
0C61: 53 0C    MOV   [__r2],A
0C63: 18       POP   A
0C64: 53 0D    MOV   [__r1],A
0C66: 18       POP   A
0C67: 38 FC    ADD   SP,252
0C69: 08       PUSH  A
0C6A: 51 0D    MOV   A,[__r1]
0C6C: 08       PUSH  A
0C6D: 51 0C    MOV   A,[__r2]
0C6F: 08       PUSH  A
0C70: 51 0B    MOV   A,[__r3]
0C72: 08       PUSH  A
0C73: 52 F9    MOV   A,[X-7]
0C75: 08       PUSH  A
0C76: 52 FA    MOV   A,[X-6]
0C78: 08       PUSH  A
0C79: 52 FB    MOV   A,[X-5]
0C7B: 08       PUSH  A
0C7C: 52 FC    MOV   A,[X-4]
0C7E: 08       PUSH  A
0C7F: 9C 2C    CALL  _init_delay_counter
0C81: 38 F8    ADD   SP,248
0C83: 62 D0 01 MOV   REG[208],1
0C86: 51 26    MOV   A,[STATUS+1]
0C88: 21 01    AND   A,1
0C8A: 62 D0 01 MOV   REG[208],1
0C8D: 53 0D    MOV   [__r1],A
0C8F: 62 D0 01 MOV   REG[208],1
0C92: 51 25    MOV   A,[STATUS]
0C94: 21 00    AND   A,0
0C96: 62 D0 01 MOV   REG[208],1
0C99: 39 00    CMP   A,0
0C9B: BF E7    JNZ   0x0C83
0C9D: 3C 0D 00 CMP   [__r1],0
0CA0: BF E2    JNZ   0x0C83
0CA2: 20       POP   X
0CA3: 7F       RET   
(0178) 
(0179) void I2Yaz()
(0180) {
(0181) 		status = I2CHW_1_bReadI2CStatus();
_I2Yaz:
0CA4: 10       PUSH  X
0CA5: 7C 06 E4 LCALL 0x06E4
0CA8: 20       POP   X
0CA9: 62 D0 01 MOV   REG[208],1
0CAC: 53 35    MOV   [status],A
(0182) 		if( status & I2CHW_RD_COMPLETE )
0CAE: 47 35 04 TST   [status],4
0CB1: A0 14    JZ    0x0CC6
(0183) 		{
(0184) 			I2CHW_1_ClrRdStatus();
0CB3: 10       PUSH  X
0CB4: 7C 06 EA LCALL 0x06EA
(0185) 			I2CHW_1_InitRamRead(txBuffer,32);}}
0CB7: 50 20    MOV   A,32
0CB9: 08       PUSH  A
0CBA: 50 00    MOV   A,0
0CBC: 08       PUSH  A
0CBD: 50 B8    MOV   A,184
0CBF: 08       PUSH  A
0CC0: 7C 06 B6 LCALL 0x06B6
0CC3: 38 FD    ADD   SP,253
0CC5: 20       POP   X
0CC6: 7F       RET   
(0186) 
(0187) void I2Oku()
(0188) {
(0189)         status = I2CHW_1_bReadI2CStatus();  
_I2Oku:
0CC7: 10       PUSH  X
0CC8: 7C 06 E4 LCALL 0x06E4
0CCB: 20       POP   X
0CCC: 62 D0 01 MOV   REG[208],1
0CCF: 53 35    MOV   [status],A
(0190)         if( status & I2CHW_WR_COMPLETE )  
0CD1: 47 35 40 TST   [status],64
0CD4: A0 14    JZ    0x0CE9
(0191)         {
(0192) 	        I2CHW_1_ClrWrStatus();  
0CD6: 10       PUSH  X
0CD7: 7C 06 F1 LCALL 0x06F1
(0193) 	        I2CHW_1_InitWrite(rxBuffer,32);}}
FILE: <library>
0CDA: 50 20    MOV   A,32
0CDC: 08       PUSH  A
0CDD: 50 00    MOV   A,0
0CDF: 08       PUSH  A
0CE0: 50 98    MOV   A,152
0CE2: 08       PUSH  A
0CE3: 7C 06 78 LCALL 0x0678
0CE6: 38 FD    ADD   SP,253
0CE8: 20       POP   X
0CE9: 7F       RET   
__divmod_32X32_32:
0CEA: 10       PUSH  X
0CEB: 4F       MOV   X,SP
0CEC: 38 01    ADD   SP,1
0CEE: 50 00    MOV   A,0
0CF0: 3D F9 80 CMP   [X-7],128
0CF3: C0 06    JC    0x0CFA
0CF5: 7C 0D 8A LCALL __i_div32_not_util
0CF8: 50 C0    MOV   A,192
0CFA: 3D F5 80 CMP   [X-11],128
0CFD: C0 0C    JC    0x0D0A
0CFF: 10       PUSH  X
0D00: 4B       SWAP  A,X
0D01: 11 04    SUB   A,4
0D03: 4B       SWAP  A,X
0D04: 7C 0D 8A LCALL __i_div32_not_util
0D07: 31 80    XOR   A,128
0D09: 20       POP   X
0D0A: 08       PUSH  A
0D0B: 7C 0D 27 LCALL __i_div32_block_util
0D0E: 18       POP   A
0D0F: 6A       RLC   A
0D10: D0 04    JNC   0x0D15
0D12: 7C 0D 8A LCALL __i_div32_not_util
0D15: 6A       RLC   A
0D16: D0 08    JNC   0x0D1F
0D18: 4B       SWAP  A,X
0D19: 11 04    SUB   A,4
0D1B: 4B       SWAP  A,X
0D1C: 7C 0D 8A LCALL __i_div32_not_util
0D1F: 38 FF    ADD   SP,255
0D21: 20       POP   X
0D22: 70 3F    AND   F,63
0D24: 71 C0    OR    F,192
0D26: 7F       RET   
__i_div32_block_util:
0D27: 5D D0    MOV   A,REG[208]
0D29: 08       PUSH  A
0D2A: 62 D0 01 MOV   REG[208],1
0D2D: 51 0E    MOV   A,[__r0]
0D2F: 08       PUSH  A
0D30: 50 00    MOV   A,0
0D32: 53 0E    MOV   [__r0],A
0D34: 53 02    MOV   [__rX],A
0D36: 53 01    MOV   [__rY],A
0D38: 53 00    MOV   [__rZ],A
0D3A: 56 00 20 MOV   [X+0],32
0D3D: 66 FC    ASL   [X-4]
0D3F: 6C FB    RLC   [X-5]
0D41: 6C FA    RLC   [X-6]
0D43: 6C F9    RLC   [X-7]
0D45: 6B 00    RLC   [__rZ]
0D47: 6B 01    RLC   [__rY]
0D49: 6B 02    RLC   [__rX]
0D4B: 6B 0E    RLC   [__r0]
0D4D: 51 00    MOV   A,[__rZ]
0D4F: 1B F8    SBB   A,[X-8]
0D51: 51 01    MOV   A,[__rY]
0D53: 1B F7    SBB   A,[X-9]
0D55: 51 02    MOV   A,[__rX]
0D57: 1B F6    SBB   A,[X-10]
0D59: 51 0E    MOV   A,[__r0]
0D5B: 1B F5    SBB   A,[X-11]
0D5D: C0 11    JC    0x0D6F
0D5F: 53 0E    MOV   [__r0],A
0D61: 52 F8    MOV   A,[X-8]
0D63: 14 00    SUB   [__rZ],A
0D65: 52 F7    MOV   A,[X-9]
0D67: 1C 01    SBB   [__rY],A
0D69: 52 F6    MOV   A,[X-10]
0D6B: 1C 02    SBB   [__rX],A
0D6D: 77 FC    INC   [X-4]
0D6F: 7B 00    DEC   [X+0]
0D71: BF CB    JNZ   0x0D3D
0D73: 51 00    MOV   A,[__rZ]
0D75: 54 F8    MOV   [X-8],A
0D77: 51 01    MOV   A,[__rY]
0D79: 54 F7    MOV   [X-9],A
0D7B: 51 02    MOV   A,[__rX]
0D7D: 54 F6    MOV   [X-10],A
0D7F: 51 0E    MOV   A,[__r0]
0D81: 54 F5    MOV   [X-11],A
0D83: 18       POP   A
0D84: 53 0E    MOV   [__r0],A
0D86: 18       POP   A
0D87: 60 D0    MOV   REG[208],A
0D89: 7F       RET   
__i_div32_not_util:
0D8A: 37 FC FF XOR   [X-4],255
0D8D: 77 FC    INC   [X-4]
0D8F: 37 FB FF XOR   [X-5],255
0D92: 0F FB 00 ADC   [X-5],0
0D95: 37 FA FF XOR   [X-6],255
0D98: 0F FA 00 ADC   [X-6],0
0D9B: 37 F9 FF XOR   [X-7],255
0D9E: 0F F9 00 ADC   [X-7],0
0DA1: 7F       RET   
--------------------------------------------------------------------------------


PSoC Designer Version: 4.4.1184

Copyright (C) 1994 - 2001 ImageCraft
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Code Compressor V1.09
ICCM8C version V1.69A
